<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Highway Racer with Main Menu</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        /* Custom CSS for 3D elements and layout control */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1f2937; /* Dark background */
        }
        
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        #canvas-3d {
            /* The canvas will be appended here and set to full screen by JS */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Basic styling for the 'pedal' visualizers */
        .pedal {
            box-shadow: 0 5px 0 0 #374151; /* Darker shadow for 3D effect */
            transition: box-shadow 0.1s, transform 0.1s;
        }

        .pedal.active {
            box-shadow: 0 2px 0 0 #374151;
            transform: translateY(3px);
        }

        /* Custom speed display styling */
        .speedometer {
            background: linear-gradient(145deg, #1f2937, #111827);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            border: 2px solid #374151;
        }

        /* Modal styling to ensure it covers everything */
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100; /* Highest z-index */
        }
        
        .menu-card {
            background: linear-gradient(135deg, #2d3748, #1a202c);
            border: 4px solid #4a5568;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            max-height: 90vh; 
            overflow-y: auto;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="canvas-3d"></div> 
    
    <div id="info-panel" class="absolute top-0 left-0 right-0 flex justify-between items-center p-4 text-white bg-gray-900 bg-opacity-80 z-20 shadow-lg hidden">
        
        <div id="speed-display" class="speedometer p-3 rounded-xl flex flex-col items-center">
            <span class="text-xs font-semibold text-gray-400">MPH</span>
            <span id="speed-value" class="text-3xl font-extrabold text-green-400">0</span>
        </div>
        
        <div class="text-center">
            <div class="text-2xl font-bold">Score: <span id="score">0</span></div>
            <div class="text-lg text-gray-400">Level: <span id="level">1</span> (<span id="environment-name">Sunny Meadow</span>)</div>
        </div>

        <button id="pause-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-xl transition duration-150" onclick="togglePause()">PAUSE (Space)</button>
    </div>
    
    <div id="controls-info" class="absolute bottom-24 md:bottom-32 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-gray-300 text-base md:text-lg text-center p-2 bg-gray-900 bg-opacity-70 rounded-lg z-20 shadow-2xl hidden">
        <p class="font-semibold">Controls: **Gas:** Up Arrow (or Hold) | **Steer:** Left/Right Arrow</p>
    </div>

    <div id="pedals-container" class="absolute bottom-5 right-5 flex gap-5 z-20 hidden">
        <div id="brake-pedal" class="pedal w-20 h-24 bg-gray-600 text-white text-lg font-bold rounded-lg flex items-center justify-center">BRAKE</div> 
        <div id="gas-pedal" class="pedal w-20 h-24 bg-gray-600 text-white text-lg font-bold rounded-lg flex items-center justify-center">GAS</div>
    </div>
</div>

<div id="modal-container"></div>

<script>
    // --- THREE.JS SETUP & CONFIGURATION ---
    const CONTAINER = document.getElementById('canvas-3d');
    let scene, camera, renderer, clock, animationFrameId;

    // --- BASE GAME CONSTANTS ---
    // **UPDATE: 8 LANES**
    const LANE_COUNT = 8; 
    const ROAD_WIDTH = 12; // Doubled road width for 8 lanes
    const CAR_SIZE = { width: (ROAD_WIDTH / LANE_COUNT) * 0.7, height: 0.5, depth: 1.5 };
    const TRUCK_SIZE = { width: (ROAD_WIDTH / LANE_COUNT) * 0.9, height: 1.0, depth: 3.0 }; 
    const SPEED_UNIT_TO_MPH = 5.33; 
    
    const CLASSIC_ROAD_COLOR = 0x222222; 
    
    // Physics and Speed constants 
    const BASE_MAX_PLAYER_SPEED = 25.0; 
    const BASE_IDLE_PLAYER_SPEED = 10.0;  
    const BASE_TRAFFIC_SPEED = 6.0;    
    const BASE_ACCELERATION_RATE = 7.0; 
    const BASE_DECELERATION_RATE = 10.0; 
    const LEVEL_MULTIPLIER = 1.08; 

    // Depth and Positioning
    const ROAD_DEPTH = 150; 
    const PLAYER_Z = 3;    
    const DESPAWN_Z = 5;   
    const FAR_Z_SPAWN = -120; // Spawn further out
    const DETAIL_COUNT = 40; 
    
    // Traffic Intensity 
    const BASE_SPAWN_INTERVAL = 0.65; 
    const TRAFFIC_MULTIPLIER = 1.25; 
    
    const MIN_LONGITUDINAL_GAP = CAR_SIZE.depth * 3.5; 
    const MIN_LATERAL_GAP = CAR_SIZE.depth * 1.2; 
    
    // **UPDATE: TRAFFIC AI CONSTANTS**
    const TRAFFIC_AI_CHECK_INTERVAL = 0.5; // How often traffic checks for lane change
    const TRAFFIC_AI_GAP_THRESHOLD = CAR_SIZE.depth * 4.5; // If gap is smaller, consider changing lane
    const LANE_CHANGE_DURATION = 0.5; // How long it takes to move lanes

    // --- ENVIRONMENT PRESETS ---
    const ENVIRONMENTS = [
        { name: "Sunny Meadow", skyColor: 0x87CEEB, fogNear: 0.4, fogFar: 0.8, grassColor: 0x38761d, foliageType: 'flowers', weather: 'none' }, 
        { name: "Autumn Dusk", skyColor: 0xcd6133, fogNear: 0.35, fogFar: 0.75, grassColor: 0x996515, foliageType: 'autumn', weather: 'none' }, 
        { name: "Heavy Rain", skyColor: 0x4d5656, fogNear: 0.15, fogFar: 0.5, grassColor: 0x3d3d3d, foliageType: 'wet', weather: 'rain' },
        { name: "Blizzard Drive", skyColor: 0xddeeff, fogNear: 0.1, fogFar: 0.4, grassColor: 0x99aaff, foliageType: 'snowy', weather: 'snow' },
        { name: "Night Ascent", skyColor: 0x1f2937, fogNear: 0.1, fogFar: 0.55, grassColor: 0x000000, foliageType: 'none', weather: 'none' },
    ];

    // --- GAME STATE ---
    let gameState = {
        score: 0,
        level: 1,
        playerSpeedUnits: BASE_IDLE_PLAYER_SPEED,
        isGameOver: false,
        isPaused: false,
        isGassing: false,
        lastTrafficSpawn: 0,
        traffic: [],
        backgroundElements: [],
        weatherParticles: null,
        currentEnvironmentIndex: 0,
        keyBindings: {
            gas: 'ArrowUp',
            left: 'ArrowLeft',
            right: 'ArrowRight'
        },
        // **UPDATE: TRAFFIC AI & BLINKERS**
        trafficAIStepTimer: 0,
        blinkTimer: 0, 
        playerCar: {
            mesh: null,
            lane: Math.floor(LANE_COUNT / 2), // Start in a central lane
            lanePositions: [], 
            targetX: 0,
            currentX: 0,
            moveSpeed: 12 
        }
    };
    
    // Dynamic Speed Variables
    let MAX_PLAYER_SPEED = BASE_MAX_PLAYER_SPEED;
    let IDLE_PLAYER_SPEED = BASE_IDLE_PLAYER_SPEED;
    let TRAFFIC_SPEED = BASE_TRAFFIC_SPEED;
    let ACCELERATION_RATE = BASE_ACCELERATION_RATE;
    let DECELERATION_RATE = BASE_DECELERATION_RATE;

    // --- UI Elements ---
    const infoPanelEl = document.getElementById('info-panel');
    const controlsInfoEl = document.getElementById('controls-info');
    const pedalsContainerEl = document.getElementById('pedals-container');
    const gasPedalEl = document.getElementById('gas-pedal');
    const brakePedalEl = document.getElementById('brake-pedal');
    const speedValueEl = document.getElementById('speed-value');
    const environmentNameEl = document.getElementById('environment-name');
    const modalContainerEl = document.getElementById('modal-container');
    const pauseButtonEl = document.getElementById('pause-button');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');

    // --- UTILITY AND 3D MESH GENERATION ---

    /** Calculates the center X position for each lane. */
    function calculateLanePositions() {
        const lanePositions = [];
        const laneWidth = ROAD_WIDTH / LANE_COUNT;
        const startX = -ROAD_WIDTH / 2; 
        for (let i = 0; i < LANE_COUNT; i++) {
            lanePositions.push(startX + i * laneWidth + laneWidth / 2);
        }
        gameState.playerCar.lanePositions = lanePositions;
    }

    // **UPDATE: IMPROVED CAR GRAPHICS AND BLINKERS**
    
    /** Creates a generic car mesh (used for player and standard traffic) with better detail. */
    function createGenericCarMesh(color) {
        const carGroup = new THREE.Group();
        const mainMaterial = new THREE.MeshStandardMaterial({ color: color, metalness: 0.5, roughness: 0.5 });
        const windowMaterial = new THREE.MeshPhongMaterial({ color: 0x2c3e50, transparent: true, opacity: 0.8 });
        const lightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Yellow/White light

        // Main Body
        const mainBodyGeometry = new THREE.BoxGeometry(CAR_SIZE.width, CAR_SIZE.height, CAR_SIZE.depth);
        const mainBody = new THREE.Mesh(mainBodyGeometry, mainMaterial);
        mainBody.position.y = CAR_SIZE.height / 2;
        carGroup.add(mainBody);

        // Cabin (Window area)
        const cabinWidth = CAR_SIZE.width * 0.8;
        const cabinHeight = CAR_SIZE.height * 0.6;
        const cabinDepth = CAR_SIZE.depth * 0.6;
        const cabinGeometry = new THREE.BoxGeometry(cabinWidth, cabinHeight, cabinDepth);
        
        const cabin = new THREE.Mesh(cabinGeometry, windowMaterial);
        cabin.position.y = CAR_SIZE.height + cabinHeight / 2;
        cabin.position.z = -CAR_SIZE.depth * 0.1;
        carGroup.add(cabin);
        
        // Front (Headlight area)
        const frontGeometry = new THREE.BoxGeometry(CAR_SIZE.width, CAR_SIZE.height * 0.5, 0.1);
        const front = new THREE.Mesh(frontGeometry, lightMaterial);
        front.position.set(0, CAR_SIZE.height * 0.25, CAR_SIZE.depth / 2 + 0.05);
        carGroup.add(front);

        // Rear (Taillight/Spoiler area)
        const rearGeometry = new THREE.BoxGeometry(CAR_SIZE.width, CAR_SIZE.height * 0.5, 0.1);
        const rearMaterial = new THREE.MeshBasicMaterial({ color: 0x880000 }); // Red taillight
        const rear = new THREE.Mesh(rearGeometry, rearMaterial);
        rear.position.set(0, CAR_SIZE.height * 0.25, -CAR_SIZE.depth / 2 - 0.05);
        carGroup.add(rear);

        // Simple Spoiler
        const spoilerGeometry = new THREE.BoxGeometry(CAR_SIZE.width * 0.8, 0.05, 0.2);
        const spoiler = new THREE.Mesh(spoilerGeometry, mainMaterial);
        spoiler.position.set(0, CAR_SIZE.height + 0.3, -CAR_SIZE.depth * 0.4);
        carGroup.add(spoiler);

        // Wheels (Simple cylinders)
        const wheelRadius = CAR_SIZE.width * 0.15;
        const wheelDepth = 0.1;
        const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelDepth, 8);
        const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 }); 
        
        const wheelPositions = [
            { x: CAR_SIZE.width * 0.45, z: CAR_SIZE.depth * 0.3 },
            { x: -CAR_SIZE.width * 0.45, z: CAR_SIZE.depth * 0.3 },
            { x: CAR_SIZE.width * 0.45, z: -CAR_SIZE.depth * 0.3 },
            { x: -CAR_SIZE.width * 0.45, z: -CAR_SIZE.depth * 0.3 },
        ];

        wheelPositions.forEach(pos => {
            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel.rotation.z = Math.PI / 2;
            wheel.position.set(pos.x, wheelRadius, pos.z);
            carGroup.add(wheel);
        });
        
        // BLINKER MESHES (Always added, visibility controlled by AI)
        const blinkerGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.1);
        const blinkerOffMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
        const leftBlinker = new THREE.Mesh(blinkerGeometry, blinkerOffMaterial);
        const rightBlinker = new THREE.Mesh(blinkerGeometry, blinkerOffMaterial);

        leftBlinker.position.set(-CAR_SIZE.width * 0.4, CAR_SIZE.height * 0.6, -CAR_SIZE.depth / 2 + 0.1);
        rightBlinker.position.set(CAR_SIZE.width * 0.4, CAR_SIZE.height * 0.6, -CAR_SIZE.depth / 2 + 0.1);
        
        leftBlinker.userData.isBlinker = 'left';
        rightBlinker.userData.isBlinker = 'right';
        
        carGroup.add(leftBlinker);
        carGroup.add(rightBlinker);

        carGroup.children.forEach(child => {
            child.castShadow = true;
            child.receiveShadow = true;
        });
        carGroup.userData.isCar = true;
        carGroup.userData.carType = 'generic';
        carGroup.userData.collisionDepth = CAR_SIZE.depth;
        return carGroup;
    }

    /** Creates a truck mesh with better detail. */
    function createTruckMesh(color) {
        const carGroup = new THREE.Group();
        const mainMaterial = new THREE.MeshStandardMaterial({ color: color, metalness: 0.3, roughness: 0.6 });
        const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.3, roughness: 0.8 }); 
        const lightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Yellow/White light

        // Main Body (Box)
        const mainBodyGeometry = new THREE.BoxGeometry(TRUCK_SIZE.width, TRUCK_SIZE.height, TRUCK_SIZE.depth);
        const mainBody = new THREE.Mesh(mainBodyGeometry, mainMaterial);
        mainBody.position.y = TRUCK_SIZE.height / 2;
        carGroup.add(mainBody);

        // Cabin (Smaller box on the front)
        const cabinWidth = TRUCK_SIZE.width * 0.8;
        const cabinHeight = TRUCK_SIZE.height * 0.6;
        const cabinDepth = TRUCK_SIZE.depth * 0.25;
        const cabinGeometry = new THREE.BoxGeometry(cabinWidth, cabinHeight, cabinDepth);
        
        const cabin = new THREE.Mesh(cabinGeometry, darkMaterial);
        cabin.position.y = TRUCK_SIZE.height + cabinHeight / 2;
        cabin.position.z = TRUCK_SIZE.depth * 0.3; // Position at the front
        carGroup.add(cabin);

        // Front (Headlight strip)
        const frontGeometry = new THREE.BoxGeometry(TRUCK_SIZE.width, TRUCK_SIZE.height * 0.2, 0.1);
        const front = new THREE.Mesh(frontGeometry, lightMaterial);
        front.position.set(0, TRUCK_SIZE.height + 0.1, TRUCK_SIZE.depth * 0.42);
        carGroup.add(front);

        // Wheels (Adjusted for truck size)
        const wheelRadius = CAR_SIZE.width * 0.2;
        const wheelDepth = 0.15;
        const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelDepth, 8);
        const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 }); 
        
        const wheelPositions = [
            { x: TRUCK_SIZE.width * 0.4, z: TRUCK_SIZE.depth * 0.4 },
            { x: -TRUCK_SIZE.width * 0.4, z: TRUCK_SIZE.depth * 0.4 },
            { x: TRUCK_SIZE.width * 0.4, z: -TRUCK_SIZE.depth * 0.4 },
            { x: -TRUCK_SIZE.width * 0.4, z: -TRUCK_SIZE.depth * 0.4 },
        ];

        wheelPositions.forEach(pos => {
            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel.rotation.z = Math.PI / 2;
            wheel.position.set(pos.x, wheelRadius, pos.z);
            carGroup.add(wheel);
        });
        
        // BLINKER MESHES (Always added, visibility controlled by AI)
        const blinkerGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.1);
        const blinkerOffMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
        const leftBlinker = new THREE.Mesh(blinkerGeometry, blinkerOffMaterial);
        const rightBlinker = new THREE.Mesh(blinkerGeometry, blinkerOffMaterial);

        leftBlinker.position.set(-TRUCK_SIZE.width * 0.4, TRUCK_SIZE.height * 0.6 + 0.1, -TRUCK_SIZE.depth / 2 + 0.1);
        rightBlinker.position.set(TRUCK_SIZE.width * 0.4, TRUCK_SIZE.height * 0.6 + 0.1, -TRUCK_SIZE.depth / 2 + 0.1);
        
        leftBlinker.userData.isBlinker = 'left';
        rightBlinker.userData.isBlinker = 'right';
        
        carGroup.add(leftBlinker);
        carGroup.add(rightBlinker);

        carGroup.children.forEach(child => {
            child.castShadow = true;
            child.receiveShadow = true;
        });
        carGroup.userData.isCar = true;
        carGroup.userData.carType = 'truck';
        carGroup.userData.collisionDepth = TRUCK_SIZE.depth; 
        return carGroup;
    }

    /** Creates a car mesh (randomly selects between types for traffic, or always generic for player). */
    function createCarMesh(color, isPlayer = false) {
        if (isPlayer) {
            return createGenericCarMesh(color);
        }

        // Randomly choose car type for traffic
        const carTypes = [createGenericCarMesh, createTruckMesh];
        const weights = [80, 20]; // 80% generic car, 20% truck

        let totalWeight = 0;
        for (const weight of weights) { totalWeight += weight; }

        let random = Math.random() * totalWeight;
        let selectedType = createGenericCarMesh; // Default to generic

        for (let i = 0; i < carTypes.length; i++) {
            random -= weights[i];
            if (random < 0) {
                selectedType = carTypes[i];
                break;
            }
        }

        const mesh = selectedType(color);
        mesh.userData.isCar = true;
        
        // **UPDATE: TRAFFIC AI INITIAL STATE**
        mesh.userData.currentX = mesh.position.x;
        mesh.userData.targetX = mesh.position.x;
        mesh.userData.laneChangeState = 'idle'; // 'idle', 'seeking', 'moving'
        mesh.userData.laneChangeTimer = Math.random() * 5 + 3; // Time until next potential change
        mesh.userData.moveSpeed = 8; // Speed of lane change
        return mesh;
    }

    // **UPDATE: ADDING SIMPLE ROADSIDE STRUCTURES (GAS STATION/REST STOP)**
    /** Creates a background foliage mesh, sign, or building block. */
    function createBackgroundMesh(style, grassColor) {
        const detailGroup = new THREE.Group();
        detailGroup.userData.isBackgroundElement = true;
        
        if (style === 'none') {
            return detailGroup; // Return empty group for "night ascent"
        }
        
        // 5% chance to spawn a roadside structure
        const structureChance = 0.05;
        
        if (style !== 'flowers' && Math.random() < structureChance) {
            // Option 1: Rest Stop Sign
            if (Math.random() < 0.5) {
                const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
                const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x777777 }); 
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.y = 0.75;
                detailGroup.add(pole);
                
                const signGeometry = new THREE.BoxGeometry(2, 0.8, 0.1);
                const signMaterial = new THREE.MeshBasicMaterial({ color: 0x006400 });
                const sign = new THREE.Mesh(signGeometry, signMaterial);
                sign.position.set(0, 1.6, 0.05);
                detailGroup.add(sign);

                // Add text effect for "REST STOP"
                const textGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.05);
                const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const text = new THREE.Mesh(textGeometry, textMaterial);
                text.position.set(0, 1.6, 0.1);
                detailGroup.add(text);
                detailGroup.userData.type = 'sign';
                
            } 
            // Option 2: Simple Building Block (Gas Station representation)
            else {
                const buildingGeometry = new THREE.BoxGeometry(4, 3, 4);
                const buildingMaterial = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.8 });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.y = 1.5;
                detailGroup.add(building);
                detailGroup.userData.type = 'building';
            }

        } else {
            // Existing foliage logic
            const trunkColor = 0x7c4912;
            let topColor = grassColor; 

            if (style === 'flowers') {
                const flowerColor = [0xFFC0CB, 0xFFA07A, 0x90EE90, 0xADD8E6][Math.floor(Math.random() * 4)];
                const geometry = new THREE.ConeGeometry(0.3, 0.4, 4);
                const material = new THREE.MeshBasicMaterial({ color: flowerColor });
                const flower = new THREE.Mesh(geometry, material);
                flower.position.y = 0.2;
                detailGroup.add(flower);
                detailGroup.userData.type = 'foliage';
            } else {
                const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: trunkColor, roughness: 1 }); 
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 0.3; 
                detailGroup.add(trunk);

                let topGeometry, topYPos;
                if (style === 'snowy' || style === 'wet') {
                    topGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
                    topYPos = 1.3;
                    topColor = style === 'snowy' ? 0xffffff : grassColor + 0x111111;
                } else {
                    topGeometry = new THREE.ConeGeometry(0.4, 1.2, 8);
                    topYPos = 1.2;
                    if (style === 'autumn') {
                        topColor = [0x992d00, 0xcc6600, 0x4d3200][Math.floor(Math.random() * 3)];
                    }
                }

                const topMaterial = new THREE.MeshStandardMaterial({ color: topColor, metalness: 0, roughness: 0.7 }); 
                const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.y = topYPos; 
                detailGroup.add(top);
                detailGroup.userData.type = 'foliage';
            }
        }


        detailGroup.children.forEach(child => {
            child.castShadow = true;
            child.receiveShadow = true;
        });
        return detailGroup;
    }

    // --- SCENE INITIALIZATION ---
    
    /** Creates the static road and the animated lane markings. */
    function createRoad() {
        // 1. Road Surface 
        const roadGeometry = new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_DEPTH, 1, 150); 
        const roadMaterial = new THREE.MeshLambertMaterial({ color: CLASSIC_ROAD_COLOR });
        const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
        roadMesh.rotation.x = -Math.PI / 2; 
        roadMesh.position.y = 0; 
        roadMesh.position.z = -ROAD_DEPTH / 2 + PLAYER_Z; 
        roadMesh.receiveShadow = true;
        roadMesh.userData.isRoad = true;
        scene.add(roadMesh);
        
        // 2. Lane Lines (White Dashes)
        const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const lineDepth = 1.2; 
        const lineGap = 1.8; 
        const totalPattern = lineDepth + lineGap;
        const numLines = Math.ceil(ROAD_DEPTH / totalPattern) * 2; 
        
        // **UPDATE: Lane lines for 8 lanes**
        for (let i = 1; i < LANE_COUNT; i++) {
            const xPos = gameState.playerCar.lanePositions[i] - ROAD_WIDTH / LANE_COUNT / 2;
            
            const lineGroup = new THREE.Group();
            lineGroup.userData.isLaneLine = true;
            
            for (let j = 0; j < numLines; j++) {
                const lineGeometry = new THREE.PlaneGeometry(0.15, lineDepth);
                const lineMesh = new THREE.Mesh(lineGeometry, lineMaterial);
                
                lineMesh.rotation.x = -Math.PI / 2;
                lineMesh.position.set(xPos, 0.01, FAR_Z_SPAWN + j * totalPattern); 
                lineGroup.add(lineMesh);
            }
            lineGroup.userData.totalZExtent = numLines * totalPattern;
            scene.add(lineGroup);
        }

        // 3. Left Railing
        const railingGeometry = new THREE.BoxGeometry(0.15, 0.4, ROAD_DEPTH); 
        const railingMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.3 }); 
        
        const leftRailing = new THREE.Mesh(railingGeometry, railingMaterial);
        leftRailing.position.set(-ROAD_WIDTH / 2 - 0.5, 0.2, -ROAD_DEPTH / 2 + PLAYER_Z);
        leftRailing.receiveShadow = true;
        leftRailing.castShadow = true;
        leftRailing.userData.isRoadDetail = true;
        scene.add(leftRailing);
        
        // 4. Right Railing
        const rightRailing = new THREE.Mesh(railingGeometry, railingMaterial);
        rightRailing.position.set(ROAD_WIDTH / 2 + 0.5, 0.2, -ROAD_DEPTH / 2 + PLAYER_Z);
        rightRailing.receiveShadow = true;
        rightRailing.castShadow = true;
        rightRailing.userData.isRoadDetail = true;
        scene.add(rightRailing);
    }

    // --- GAME LOGIC FUNCTIONS ---
    
    /** Finds the closest traffic car in a given lane within a Z range. */
    function findCarAhead(currentCar, lane, maxDistance) {
        let closestCar = null;
        let minDistance = maxDistance;

        for (const otherCar of gameState.traffic) {
            // Skip the car itself and cars not in the target lane
            if (otherCar === currentCar || otherCar.userData.lane !== lane) continue;

            const carZ = currentCar.position.z;
            const otherCarZ = otherCar.position.z;
            const otherCarDepth = otherCar.userData.collisionDepth || CAR_SIZE.depth;
            
            // Only consider cars *ahead*
            const distance = otherCarZ - carZ;

            if (distance > 0 && distance < minDistance) {
                closestCar = otherCar;
                minDistance = distance - (otherCarDepth / 2 + (currentCar.userData.collisionDepth || CAR_SIZE.depth) / 2);
            }
        }

        return minDistance; 
    }

    /** Traffic AI decision logic for lane changing. */
    function trafficAIStep() {
        // Only run for traffic cars that are 'idle' or 'seeking'
        gameState.traffic.filter(car => car.userData.laneChangeState !== 'moving').forEach(car => {
            
            // 1. Check if the car ahead is too close (only if idle or seeking)
            const gapAhead = findCarAhead(car, car.userData.lane, TRAFFIC_AI_GAP_THRESHOLD);
            
            if (gapAhead < TRAFFIC_AI_GAP_THRESHOLD) {
                car.userData.laneChangeState = 'seeking';
                
                // 2. Try to find a safe lane (Left or Right)
                const currentLane = car.userData.lane;
                const lanesToTry = [];
                
                // Prioritize the lane that is not towards the wall
                if (currentLane > 0) lanesToTry.push(currentLane - 1); // Try left
                if (currentLane < LANE_COUNT - 1) lanesToTry.push(currentLane + 1); // Try right
                
                // Shuffle the order to make it less predictable
                if (Math.random() > 0.5 && lanesToTry.length === 2) { lanesToTry.reverse(); }

                for (const newLane of lanesToTry) {
                    // Check if the new lane is clear enough (longer gap for lateral movement)
                    const frontGap = findCarAhead(car, newLane, MIN_LONGITUDINAL_GAP * 2); 
                    // Also check for cars behind that might crash into us during the change (using a small distance from the back)
                    const backGap = findCarAhead(car, newLane, -MIN_LONGITUDINAL_GAP * 1.5); 
                    
                    if (frontGap > MIN_LONGITUDINAL_GAP * 2 && backGap < 0) { // Safe lane found
                        car.userData.laneChangeState = 'moving';
                        car.userData.targetLane = newLane;
                        car.userData.targetX = gameState.playerCar.lanePositions[newLane];
                        car.userData.laneChangeTimer = LANE_CHANGE_DURATION;
                        return; // Exit the loop for this car
                    }
                }
            } else {
                car.userData.laneChangeState = 'idle';
                car.userData.targetLane = car.userData.lane;
                car.userData.targetX = gameState.playerCar.lanePositions[car.userData.lane];
            }
            
            // If still seeking and couldn't move, go back to idle to re-evaluate later
            if (car.userData.laneChangeState === 'seeking') {
                car.userData.laneChangeState = 'idle';
            }
        });
    }

    /** Moves and wraps all dynamic elements to create the infinite road effect. */
    function updateMotion(deltaTime) {
        const playerCar = gameState.playerCar;
        const { playerSpeedUnits, traffic } = gameState;

        // 1. Update Player Car Speed
        if (gameState.isGassing) {
            gameState.playerSpeedUnits = Math.min(MAX_PLAYER_SPEED, playerSpeedUnits + ACCELERATION_RATE * deltaTime);
            gasPedalEl.classList.add('active', 'bg-green-500');
            brakePedalEl.classList.remove('active', 'bg-red-500');
            
        } else {
            if (playerSpeedUnits > IDLE_PLAYER_SPEED) {
                gameState.playerSpeedUnits = Math.max(IDLE_PLAYER_SPEED, playerSpeedUnits - DECELERATION_RATE * deltaTime);
            }
            gasPedalEl.classList.remove('active', 'bg-green-500');
            brakePedalEl.classList.add('active', 'bg-red-500');
        }

        // 2. Player Car Lane Change (Smooth movement)
        playerCar.currentX += (playerCar.targetX - playerCar.currentX) * playerCar.moveSpeed * deltaTime;
        playerCar.mesh.position.x = playerCar.currentX;

        // 3. Traffic AI Update Check
        gameState.trafficAIStepTimer += deltaTime;
        if (gameState.trafficAIStepTimer > TRAFFIC_AI_CHECK_INTERVAL) {
            trafficAIStep();
            gameState.trafficAIStepTimer = 0;
        }

        // 4. Blinker Timer Update
        gameState.blinkTimer = (gameState.blinkTimer + deltaTime) % 0.5; // Blink every 0.5s

        // 5. Motion Calculations
        const trafficRelativeMoveDistance = (playerSpeedUnits - TRAFFIC_SPEED) * deltaTime;
        const roadMoveDistance = playerSpeedUnits * deltaTime;
        
        // 6. Move and Check Traffic Cars
        for (let i = traffic.length - 1; i >= 0; i--) {
            const carMesh = traffic[i];
            
            carMesh.position.z += trafficRelativeMoveDistance; 
            
            // **UPDATE: TRAFFIC LANE CHANGING MOVEMENT**
            if (carMesh.userData.laneChangeState === 'moving') {
                carMesh.userData.laneChangeTimer -= deltaTime;
                
                // Move towards target X
                carMesh.userData.currentX += (carMesh.userData.targetX - carMesh.userData.currentX) * carMesh.userData.moveSpeed * deltaTime;
                carMesh.position.x = carMesh.userData.currentX;

                if (carMesh.userData.laneChangeTimer <= 0) {
                    carMesh.userData.laneChangeState = 'idle';
                    carMesh.userData.lane = carMesh.userData.targetLane;
                    carMesh.position.x = carMesh.userData.targetX; // Snap to center for stability
                }
            } else {
                 // Snap car's position to its current lane center if not moving
                 carMesh.position.x += (carMesh.userData.targetX - carMesh.position.x) * carMesh.userData.moveSpeed * 0.5 * deltaTime;
            }
            
            // **UPDATE: BLINKER VISUALS**
            carMesh.children.forEach(child => {
                if (child.userData.isBlinker) {
                    const isLeft = child.userData.isBlinker === 'left';
                    const isRight = child.userData.isBlinker === 'right';
                    
                    let shouldBlink = false;
                    const targetLane = carMesh.userData.targetLane;

                    if (carMesh.userData.laneChangeState === 'moving') {
                        if (targetLane < carMesh.userData.lane && isLeft) shouldBlink = true; // Moving Left
                        if (targetLane > carMesh.userData.lane && isRight) shouldBlink = true; // Moving Right
                    }
                    
                    if (shouldBlink) {
                        const blinkerOn = gameState.blinkTimer > 0.25;
                        child.material.color.set(blinkerOn ? 0xffa500 : 0x333333); // Orange for ON
                    } else {
                        child.material.color.set(0x333333); // Off/Dark
                    }
                }
            });


            if (checkCollision(playerCar.mesh, carMesh)) {
                gameState.isGameOver = true;
                showGameOverScreen();
                return;
            }

            if (carMesh.position.z > DESPAWN_Z) {
                scene.remove(carMesh);
                traffic.splice(i, 1);
            }
        }

        // 7. Handle Traffic Spawning 
        gameState.lastTrafficSpawn += deltaTime;
        const requiredTime = BASE_SPAWN_INTERVAL / Math.pow(TRAFFIC_MULTIPLIER, gameState.level - 1); 

        if (gameState.lastTrafficSpawn > requiredTime) {
            let newLane = Math.floor(Math.random() * LANE_COUNT);
            let attempts = 0;
            const maxAttempts = LANE_COUNT * 2; 

            // Loop to find a safe lane to spawn in
            while (!isSpawnSafe(newLane) && attempts < maxAttempts) {
                newLane = (newLane + 1) % LANE_COUNT; // Cycle to the next lane
                attempts++;
            }

            // Only spawn if a safe lane was found within attempts
            if (isSpawnSafe(newLane)) {
                createTrafficCar(newLane);
            }
            
            gameState.lastTrafficSpawn = 0; 
        }

        // 8. Move Lane Lines and Background Elements (Infinite Road Effect)
        scene.children.forEach(child => {
            if (child.userData.isLaneLine) {
                const totalZExtent = child.userData.totalZExtent;
                child.children.forEach(line => {
                    line.position.z += roadMoveDistance; 
                    if (line.position.z > PLAYER_Z + line.geometry.parameters.height) { 
                        line.position.z -= totalZExtent; 
                    }
                });
            } else if (child.userData.isBackgroundElement && child !== grassMesh) {
                child.position.z += roadMoveDistance; 
                if (child.position.z > DESPAWN_Z) {
                    child.position.z -= ROAD_DEPTH + 30; // Wrap back to the far end
                }
            }
        });
        
        // 9. Update Weather Particles
        updateWeatherParticles(deltaTime);
    }
    
    /** Checks for collision between player car and traffic car (AABB simple check) */
    function checkCollision(player, trafficMesh) {
        const playerZ = PLAYER_Z; 
        const trafficZ = trafficMesh.position.z;
        const halfWidth = CAR_SIZE.width / 2;
        const halfDepth = CAR_SIZE.depth / 2;
        
        // Use the car's dynamic collision depth 
        const trafficCollisionDepth = trafficMesh.userData.collisionDepth || CAR_SIZE.depth; 
        const trafficHalfDepth = trafficCollisionDepth / 2; 

        // 1. X-axis overlap check: Use their current X positions
        const playerMinX = player.position.x - halfWidth * 0.9; 
        const playerMaxX = player.position.x + halfWidth * 0.9;
        const trafficMinX = trafficMesh.position.x - halfWidth * 0.9;
        const trafficMaxX = trafficMesh.position.x + halfWidth * 0.9;

        const xOverlap = Math.max(0, Math.min(playerMaxX, trafficMaxX) - Math.max(playerMinX, trafficMinX));

        if (xOverlap > CAR_SIZE.width * 0.1) {
            // 2. Z-axis overlap
            const playerFrontZ = playerZ + halfDepth;
            const playerBackZ = playerZ - halfDepth;
            
            const trafficFrontZ = trafficZ + trafficHalfDepth;
            const trafficBackZ = trafficZ - trafficHalfDepth;

            // Use a slight tolerance to ensure the collision is forgiving but solid
            if (playerFrontZ > trafficBackZ + 0.1 && playerBackZ < trafficFrontZ - 0.1) {
                return true;
            }
        }
        return false;
    }


    /** Updates UI elements and checks for level progression. */
    function updateUI(deltaTime) {
        const { score, level, playerSpeedUnits } = gameState;
        
        // Score update
        gameState.score += playerSpeedUnits * deltaTime * 10; 
        scoreEl.textContent = Math.floor(gameState.score);
        
        // Speed update
        speedValueEl.textContent = Math.floor(playerSpeedUnits * SPEED_UNIT_TO_MPH);

        // Level check
        const newLevel = Math.floor(score / 3500) + 1; 
        if (newLevel > level) {
            gameState.level = newLevel;
            levelEl.textContent = gameState.level;
            scaleGameSpeed(); 
            updateEnvironment(gameState.level); 
        }
    }


    // --- GAME CONTROL FUNCTIONS ---
    
    /** Global function to update keybindings from the settings menu. */
    window.updateKeybinding = function(action, elementId) {
        const button = document.getElementById(elementId);
        const originalText = button.textContent;
        button.textContent = 'Press a key...';
        
        const handler = (e) => {
            const newKey = e.key;
            
            // Check for duplicate keys 
            for (const key in gameState.keyBindings) {
                if (key !== action && gameState.keyBindings[key] === newKey) {
                    alert(`Key '${newKey}' is already used for ${key.toUpperCase()}.`);
                    button.textContent = originalText; // Revert to current key
                    document.removeEventListener('keydown', handler);
                    return;
                }
            }

            gameState.keyBindings[action] = newKey;
            button.textContent = newKey;

            updateControlsInfo(); 
            
            document.removeEventListener('keydown', handler);
        };

        button.blur(); 
        
        document.removeEventListener('keydown', handler);
        document.addEventListener('keydown', handler, { once: true });
    };

    /** Updates the on-screen controls info with the current keybindings. */
    function updateControlsInfo() {
        const gasKey = gameState.keyBindings.gas;
        const leftKey = gameState.keyBindings.left;
        const rightKey = gameState.keyBindings.right;
        
        const gasDisplay = gasKey === ' ' ? 'Spacebar' : gasKey;
        const leftDisplay = leftKey === ' ' ? 'Spacebar' : leftKey;
        const rightDisplay = rightKey === ' ' ? 'Spacebar' : rightKey;

        controlsInfoEl.innerHTML = `<p class="font-semibold">Controls: **Gas:** ${gasDisplay} (or Hold) | **Steer:** ${leftDisplay}/${rightDisplay}</p>`;
    }

    /** Shows the main menu screen. */
    function showMainMenu() {
        // Ensure UI elements are hidden
        infoPanelEl.classList.add('hidden');
        controlsInfoEl.classList.add('hidden');
        pedalsContainerEl.classList.add('hidden');
        
        // Clear old scene items
        for (let i = scene.children.length - 1; i >= 0; i--) {
            const child = scene.children[i];
            if (child.userData.isCar || child.userData.isLaneLine || child.userData.isRoad || child.userData.isBackgroundElement || child.userData.isWeather || child.userData.isRoadDetail) {
                scene.remove(child);
                child.geometry?.dispose();
                child.material?.dispose();
            }
        }

        modalContainerEl.innerHTML = `
            <div class="modal-overlay">
                <div class="menu-card rounded-2xl p-8 md:p-12 text-center text-white w-11/12 md:w-96">
                    <h1 class="text-6xl font-extrabold mb-4 text-yellow-400 tracking-wider shadow-white">RADIAL RACE</h1>
                    <p class="text-xl text-gray-300 mb-8">Endless high-speed highway action.</p>
                    
                    <div class="space-y-4">
                        <button onclick="startGame()" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-4 rounded-lg shadow-lg transition duration-200 text-xl tracking-wider">
                            START RACE
                        </button>
                        <button onclick="showHowToPlay()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg shadow-md transition duration-200">
                            HOW TO PLAY
                        </button>
                        <button onclick="showSettingsMenu()" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 rounded-lg shadow-md transition duration-200">
                            SETTINGS (Keybinds)
                        </button>
                        </div>
                </div>
            </div>
        `;
    }

    /** Toggles the game's paused state and shows the modal. */
    window.togglePause = function() {
        if (gameState.isGameOver) return; 

        gameState.isPaused = !gameState.isPaused;

        if (gameState.isPaused) {
            pauseButtonEl.textContent = 'RESUME (Space)';
            modalContainerEl.innerHTML = `
                <div class="modal-overlay">
                    <div class="menu-card rounded-xl p-10 text-center text-white shadow-2xl z-50 w-11/12 md:w-1/3">
                        <h2 class="text-4xl font-extrabold mb-4 text-yellow-400">GAME PAUSED</h2>
                        <p class="text-lg mb-6">Take a breath. Press 'RESUME' or the Spacebar to get back on the road.</p>
                        <button onclick="togglePause()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition duration-200">RESUME</button>
                    </div>
                </div>
            `;
            cancelAnimationFrame(animationFrameId);
        } else {
            pauseButtonEl.textContent = 'PAUSE (Space)';
            modalContainerEl.innerHTML = '';
            gameLoop();
        }
    }

    /** Resets the game state and initializes all objects for a new game. */
    window.startGame = function() {
        // Clear all scene dynamic items 
        for (let i = scene.children.length - 1; i >= 0; i--) {
            const child = scene.children[i];
            if (child.userData.isCar || child.userData.isLaneLine || child.userData.isRoad || child.userData.isBackgroundElement || child.userData.isWeather || child.userData.isRoadDetail) {
                scene.remove(child);
                child.geometry?.dispose();
                child.material?.dispose();
            }
        }
        
        // Reset state variables
        gameState.score = 0;
        gameState.level = 1;
        gameState.isGameOver = false;
        gameState.isPaused = false;
        gameState.traffic = [];
        gameState.backgroundElements = [];
        gameState.lastTrafficSpawn = 0;
        gameState.trafficAIStepTimer = 0; // Reset AI timer
        cleanupWeather(); 

        scaleGameSpeed(); 
        gameState.playerSpeedUnits = IDLE_PLAYER_SPEED;
        
        // Setup lanes if first run
        if (gameState.playerCar.lanePositions.length === 0) {
            calculateLanePositions();
        }

        // Create player car (distinct blue)
        gameState.playerCar.mesh = createCarMesh(0x3498db, true); 
        gameState.playerCar.lane = Math.floor(LANE_COUNT / 2); // Start in a central lane
        gameState.playerCar.mesh.position.set(gameState.playerCar.lanePositions[gameState.playerCar.lane], 0, PLAYER_Z);
        gameState.playerCar.targetX = gameState.playerCar.lanePositions[gameState.playerCar.lane];
        gameState.playerCar.currentX = gameState.playerCar.lanePositions[gameState.playerCar.lane];
        scene.add(gameState.playerCar.mesh);

        // Rebuild static scene elements
        createRoad();
        updateEnvironment(1); 
        
        // Update UI visibility
        infoPanelEl.classList.remove('hidden');
        controlsInfoEl.classList.remove('hidden');
        pedalsContainerEl.classList.remove('hidden');
        scoreEl.textContent = 0;
        levelEl.textContent = 1;
        modalContainerEl.innerHTML = '';
        pauseButtonEl.textContent = 'PAUSE (Space)';
        
        updateControlsInfo(); 

        // Reset pedal visuals
        gasPedalEl.classList.remove('active', 'bg-green-500');
        brakePedalEl.classList.add('active', 'bg-red-500'); 
        
        clock.start();
        gameLoop();
    }


    // --- MAIN GAME LOOP ---

    function gameLoop() {
        if (gameState.isGameOver || gameState.isPaused) {
            cancelAnimationFrame(animationFrameId);
            return;
        }
        
        const deltaTime = clock.getDelta(); 
        
        // 1. Update all game physics and movement
        updateMotion(deltaTime);
        
        // 2. Update all UI displays and check for progression
        updateUI(deltaTime);

        // 3. Render the 3D scene
        renderer.render(scene, camera);

        animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- THREE.JS SETUP & INITIALIZATION ---

    /** Initializes the Three.js scene, camera, and renderer. */
    function initThreeJS() {
        // 1. Scene Setup (Global)
        scene = new THREE.Scene();
        clock = new THREE.Clock();
        
        // 2. Camera Setup
        // Increased FoV slightly for better perspective on 8 lanes
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3.5, 5);
        camera.rotation.x = -0.3; // Angle the camera down slightly
        
        // 3. Renderer Setup
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadows
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        CONTAINER.appendChild(renderer.domElement);
        
        // 4. Lighting Setup
        // Ambient Light (Soft overall light)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        // Directional Light (Sun)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5); 
        directionalLight.castShadow = true;
        
        // Configure Shadow Properties
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -ROAD_WIDTH/2 - 5;
        directionalLight.shadow.camera.right = ROAD_WIDTH/2 + 5;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;

        scene.add(directionalLight);

        window.addEventListener('resize', onWindowResize);
    }
    
    /** Handles window resizing to maintain aspect ratio and size. */
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- ENVIRONMENT & WEATHER FX ---

    let grassMesh = null;

    /** Updates the visual style of the game based on the current level/environment. */
    function updateEnvironment(level) {
        // Cycle through environments based on level
        const envIndex = (level - 1) % ENVIRONMENTS.length;
        gameState.currentEnvironmentIndex = envIndex;
        const env = ENVIRONMENTS[envIndex];
        
        // 1. Fog and Sky
        scene.fog = new THREE.Fog(env.skyColor, ROAD_DEPTH * env.fogNear, ROAD_DEPTH * env.fogFar);
        renderer.setClearColor(env.skyColor);
        environmentNameEl.textContent = env.name;
        
        // 2. Grass/Scenery Mesh (The large side planes)
        if (grassMesh) {
            scene.remove(grassMesh);
            grassMesh.geometry.dispose();
            grassMesh.material.dispose();
        }
        
        const grassGeometry = new THREE.PlaneGeometry(ROAD_WIDTH * 4, ROAD_DEPTH + 100); 
        const grassMaterial = new THREE.MeshLambertMaterial({ color: env.grassColor });
        
        grassMesh = new THREE.Mesh(grassGeometry, grassMaterial);
        grassMesh.rotation.x = -Math.PI / 2;
        grassMesh.position.y = -0.05; 
        grassMesh.position.z = -ROAD_DEPTH / 2 + PLAYER_Z;
        scene.add(grassMesh);
        grassMesh.receiveShadow = true;
        grassMesh.userData.isBackgroundElement = true; // Mark for potential motion update if needed

        // 3. Static Background Details (Trees, Signs, Buildings)
        createBackgroundElements(env);
        
        // 4. Weather Particles
        cleanupWeather();
        if (env.weather === 'rain' || env.weather === 'snow') {
            createWeatherParticleSystem(env.weather);
        }
    }
    
    /** Creates the static background elements (trees, signs, etc.). */
    function createBackgroundElements(env) {
        // Remove old elements first
        gameState.backgroundElements.forEach(el => scene.remove(el));
        gameState.backgroundElements = [];
        
        // Populate the sides with new details
        for (let i = 0; i < DETAIL_COUNT; i++) {
            const zPos = FAR_Z_SPAWN + (i / DETAIL_COUNT) * (ROAD_DEPTH + 150); 

            // Left Side 
            const leftX = -ROAD_WIDTH / 2 - 3 - Math.random() * 5;
            const leftDetail = createBackgroundMesh(env.foliageType, env.grassColor);
            leftDetail.position.set(leftX, 0, zPos);
            scene.add(leftDetail);
            gameState.backgroundElements.push(leftDetail);
            
            // Right Side
            const rightX = ROAD_WIDTH / 2 + 3 + Math.random() * 5;
            const rightDetail = createBackgroundMesh(env.foliageType, env.grassColor);
            rightDetail.position.set(rightX, 0, zPos);
            scene.add(rightDetail);
            gameState.backgroundElements.push(rightDetail);
        }
    }

    /** Creates the particle system for rain or snow. */
    function createWeatherParticleSystem(type) {
        const particleCount = 2000;
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const color = type === 'snow' ? 0xffffff : 0xAAAAFF;
        const size = type === 'snow' ? 0.3 : 0.05;

        for (let i = 0; i < particleCount; i++) {
            // Spread particles high and wide
            const x = (Math.random() * ROAD_WIDTH * 3) - ROAD_WIDTH * 1.5; 
            const y = Math.random() * 30 + 5;
            const z = (Math.random() * ROAD_DEPTH) - ROAD_DEPTH / 2 - 5; 
            positions.push(x, y, z);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({
            color: color,
            size: size,
            transparent: true,
            opacity: 0.8,
            map: createParticleTexture(), 
            blending: THREE.AdditiveBlending,
            depthWrite: false 
        });

        gameState.weatherParticles = new THREE.Points(geometry, material);
        gameState.weatherParticles.userData.isWeather = true;
        scene.add(gameState.weatherParticles);
    }
    
    /** Creates a simple white circle texture for particles. */
    function createParticleTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 16;
        canvas.height = 16;
        const context = canvas.getContext('2d');
        context.beginPath();
        context.arc(8, 8, 8, 0, Math.PI * 2, false);
        context.fillStyle = 'rgba(255, 255, 255, 1)';
        context.fill();
        return new THREE.CanvasTexture(canvas);
    }
    
    /** Updates the position of weather particles for movement and falling. */
    function updateWeatherParticles(deltaTime) {
        if (!gameState.weatherParticles) return;

        const positions = gameState.weatherParticles.geometry.attributes.position.array;
        const env = ENVIRONMENTS[gameState.currentEnvironmentIndex];
        const fallSpeed = env.weather === 'snow' ? 5 : 20; 
        const forwardSpeed = gameState.playerSpeedUnits * 0.5; // Wind effect

        for (let i = 0; i < positions.length; i += 3) {
            // X (Drift/Wind)
            positions[i] += (Math.random() - 0.5) * 0.5 * deltaTime;
            
            // Y (Falling)
            positions[i + 1] -= fallSpeed * deltaTime;
            
            // Z (Relative movement)
            positions[i + 2] += forwardSpeed * deltaTime;

            // Loop Y: If particle falls below the road, reset it high up
            if (positions[i + 1] < 0) {
                positions[i + 1] = Math.random() * 30 + 5;
            }
            
            // Loop Z: If particle moves past the camera, reset it far back
            if (positions[i + 2] > DESPAWN_Z) {
                positions[i + 2] -= ROAD_DEPTH;
            }
        }

        gameState.weatherParticles.geometry.attributes.position.needsUpdate = true;
    }

    /** Removes weather particles from the scene. */
    function cleanupWeather() {
        if (gameState.weatherParticles) {
            scene.remove(gameState.weatherParticles);
            gameState.weatherParticles.geometry.dispose();
            gameState.weatherParticles.material.dispose();
            gameState.weatherParticles = null;
        }
    }
    
    // --- TRAFFIC & SPEED SCALING ---

    /** Creates a new traffic car in a specified lane. */
    function createTrafficCar(lane) {
        const randomColor = Math.random() * 0xffffff;
        const carMesh = createCarMesh(randomColor, false);
        
        carMesh.userData.lane = lane;
        carMesh.userData.currentX = gameState.playerCar.lanePositions[lane];
        carMesh.userData.targetX = gameState.playerCar.lanePositions[lane];
        carMesh.position.set(gameState.playerCar.lanePositions[lane], 0, FAR_Z_SPAWN);
        
        gameState.traffic.push(carMesh);
        scene.add(carMesh);
    }
    
    /** Checks if a lane is safe to spawn a new car in (no existing car too close). */
    function isSpawnSafe(lane) {
        // Check for any existing traffic car that is too close to the spawn zone
        for (const car of gameState.traffic) {
            if (car.userData.lane === lane && car.position.z < FAR_Z_SPAWN + MIN_LATERAL_GAP) {
                return false; 
            }
        }
        return true;
    }
    
    /** Increases game difficulty by scaling speed variables based on the level. */
    function scaleGameSpeed() {
        const factor = Math.pow(LEVEL_MULTIPLIER, gameState.level - 1);
        MAX_PLAYER_SPEED = BASE_MAX_PLAYER_SPEED * factor;
        IDLE_PLAYER_SPEED = BASE_IDLE_PLAYER_SPEED * factor;
        TRAFFIC_SPEED = BASE_TRAFFIC_SPEED * factor;
        ACCELERATION_RATE = BASE_ACCELERATION_RATE * factor * 0.8; // Player accel scales slower
        DECELERATION_RATE = BASE_DECELERATION_RATE * factor;
    }
    
    // --- MENU AND GAME STATE SCREENS (FIXED HTML TEMPLATES) ---

    /** Shows the game over screen with final score. */
    function showGameOverScreen() {
        cancelAnimationFrame(animationFrameId);
        
        // Hide game UI
        infoPanelEl.classList.add('hidden');
        controlsInfoEl.classList.add('hidden');
        pedalsContainerEl.classList.add('hidden');
        
        const finalScore = Math.floor(gameState.score);
        const finalLevel = gameState.level;

        modalContainerEl.innerHTML = `
            <div class="modal-overlay">
                <div class="menu-card rounded-xl p-10 text-center text-white w-11/12 md:w-96">
                    <h2 class="text-6xl font-extrabold mb-4 text-red-600">CRASHED!</h2>
                    <p class="text-xl mb-2 text-gray-300">Final Score:</p>
                    <p class="text-5xl font-extrabold mb-4 text-yellow-400">${finalScore}</p>
                    <p class="text-lg mb-6 text-gray-300">Max Level Reached: ${finalLevel}</p>
                    
                    <button onclick="showMainMenu()" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg shadow-lg transition duration-200">
                        RETURN TO MAIN MENU
                    </button>
                </div>
            </div>
        `;
    }

    /** Shows the 'How to Play' instructions modal. */
    function showHowToPlay() {
        modalContainerEl.innerHTML = `
            <div class="modal-overlay">
                <div class="menu-card rounded-xl p-8 text-white w-11/12 md:w-1/2">
                    <h2 class="text-3xl font-extrabold mb-4 text-blue-400 text-center">HOW TO PLAY</h2>
                    
                    <div class="space-y-4 text-left">
                        <p><strong>Goal:</strong> Drive as fast and far as you can without hitting another vehicle!</p>
                        
                        <h3 class="text-xl font-semibold mt-4 text-gray-300">Controls</h3>
                        <ul class="list-disc list-inside ml-4">
                            <li><strong>GAS:</strong> Press and hold the **${gameState.keyBindings.gas}** key (or Up Arrow).</li>
                            <li><strong>STEER:</strong> Use **${gameState.keyBindings.left}** (Left Arrow) and **${gameState.keyBindings.right}** (Right Arrow) to change lanes.</li>
                            <li><strong>PAUSE:</strong> Press **Spacebar** to pause the game.</li>
                            <li><strong>Brake:</strong> Release the gas key or press **ArrowDown**.</li>
                        </ul>
                        
                        <h3 class="text-xl font-semibold mt-4 text-gray-300">Gameplay Tips</h3>
                        <ul class="list-disc list-inside ml-4">
                            <li>Your speed will naturally decrease if you stop gassing. Maintain speed to increase your score quickly.</li>
                            <li>Levels increase score multiplier, but also **increase the speed of all traffic** and player max speed.</li>
                            <li>NPC cars will try to change lanes to avoid you, so watch their **blinkers**!</li>
                        </ul>
                    </div>
                    
                    <button onclick="showMainMenu()" class="mt-6 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 rounded-lg transition duration-200">
                        BACK TO MENU
                    </button>
                </div>
            </div>
        `;
    }

    /** Shows the Settings menu for key rebinding. */
    function showSettingsMenu() {
        modalContainerEl.innerHTML = `
            <div class="modal-overlay">
                <div class="menu-card rounded-xl p-8 text-white w-11/12 md:w-96">
                    <h2 class="text-3xl font-extrabold mb-6 text-purple-400 text-center">KEYBINDINGS</h2>
                    
                    <div class="space-y-4">
                        <div class="flex justify-between items-center p-3 bg-gray-700 rounded-lg">
                            <span>Accelerate (Gas):</span>
                            <button id="gas-key-btn" onclick="updateKeybinding('gas', 'gas-key-btn')" class="bg-gray-500 hover:bg-gray-600 px-4 py-2 rounded-lg font-mono">${gameState.keyBindings.gas}</button>
                        </div>
                        
                        <div class="flex justify-between items-center p-3 bg-gray-700 rounded-lg">
                            <span>Steer Left:</span>
                            <button id="left-key-btn" onclick="updateKeybinding('left', 'left-key-btn')" class="bg-gray-500 hover:bg-gray-600 px-4 py-2 rounded-lg font-mono">${gameState.keyBindings.left}</button>
                        </div>
                        
                        <div class="flex justify-between items-center p-3 bg-gray-700 rounded-lg">
                            <span>Steer Right:</span>
                            <button id="right-key-btn" onclick="updateKeybinding('right', 'right-key-btn')" class="bg-gray-500 hover:bg-gray-600 px-4 py-2 rounded-lg font-mono">${gameState.keyBindings.right}</button>
                        </div>
                        
                        <p class="text-sm text-center text-gray-400 pt-2">**Note: Spacebar is always PAUSE/RESUME.</p>
                    </div>
                    
                    <button onclick="showMainMenu()" class="mt-6 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 rounded-lg transition duration-200">
                        BACK TO MENU
                    </button>
                </div>
            </div>
        `;
    }
    
    // --- INPUT HANDLING (Updated to use keybindings) ---
    
    document.addEventListener('keydown', (e) => {
        if (gameState.isGameOver) return;
        
        // Always allow spacebar to pause/resume regardless of keybindings
        if (e.key === ' ' || e.key === 'Spacebar') {
            e.preventDefault();
            togglePause();
            return;
        }

        if (gameState.isPaused) return;

        let newLane = gameState.playerCar.lane;

        // >> START UPDATED KEYBINDINGS
        if (e.key === gameState.keyBindings.left) {
            newLane = Math.max(0, gameState.playerCar.lane - 1);
        } else if (e.key === gameState.keyBindings.right) {
            newLane = Math.min(LANE_COUNT - 1, gameState.playerCar.lane + 1);
        } else if (e.key === gameState.keyBindings.gas) {
            gameState.isGassing = true;
        } else if (e.key === 'ArrowDown') { // Always allow ArrowDown as a universal 'brake' key
            gameState.isGassing = false; 
        }
        // >> END UPDATED KEYBINDINGS
        
        if (newLane !== gameState.playerCar.lane) {
            gameState.playerCar.lane = newLane;
            gameState.playerCar.targetX = gameState.playerCar.lanePositions[newLane];
        }
    });
    
    document.addEventListener('keyup', (e) => {
        // >> START UPDATED KEYBINDINGS
        if (e.key === gameState.keyBindings.gas) {
            gameState.isGassing = false;
        }
        // >> END UPDATED KEYBINDINGS
    });

    // --- INITIALIZATION ---
    
    // Start the game by showing the main menu
    window.onload = function () {
        initThreeJS();
        showMainMenu(); 
    }
</script>

</body>
</html>
