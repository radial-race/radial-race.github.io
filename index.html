<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Highway Racer with Main Menu</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        /* Custom CSS for 3D elements and layout control */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1f2937; /* Dark background */
        }
        
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        #canvas-3d {
            /* The canvas will be appended here and set to full screen by JS */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Basic styling for the 'pedal' visualizers */
        .pedal {
            box-shadow: 0 5px 0 0 #374151; /* Darker shadow for 3D effect */
            transition: box-shadow 0.1s, transform 0.1s;
        }

        .pedal.active {
            box-shadow: 0 2px 0 0 #374151;
            transform: translateY(3px);
        }

        /* Custom speed display styling */
        .speedometer {
            background: linear-gradient(145deg, #1f2937, #111827);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            border: 2px solid #374151;
        }

        /* Modal styling to ensure it covers everything */
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100; /* Highest z-index */
        }
        
        .menu-card {
            background: linear-gradient(135deg, #2d3748, #1a202c);
            border: 4px solid #4a5568;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            /* --- FIX: Added max height and overflow scroll for responsiveness --- */
            max-height: 90vh; 
            overflow-y: auto;
            /* -------------------------------------------------------------------- */
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="canvas-3d"></div> 
    
    <div id="info-panel" class="absolute top-0 left-0 right-0 flex justify-between items-center p-4 text-white bg-gray-900 bg-opacity-80 z-20 shadow-lg hidden">
        
        <div id="speed-display" class="speedometer p-3 rounded-xl flex flex-col items-center">
            <span class="text-xs font-semibold text-gray-400">MPH</span>
            <span id="speed-value" class="text-3xl font-extrabold text-green-400">0</span>
        </div>
        
        <div class="text-center">
            <div class="text-2xl font-bold">Score: <span id="score">0</span></div>
            <div class="text-lg text-gray-400">Level: <span id="level">1</span> (<span id="environment-name">Sunny Meadow</span>)</div>
        </div>

        <button id="pause-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-xl transition duration-150" onclick="togglePause()">PAUSE (Space)</button>
    </div>
    
    <div id="controls-info" class="absolute bottom-24 md:bottom-32 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-gray-300 text-base md:text-lg text-center p-2 bg-gray-900 bg-opacity-70 rounded-lg z-20 shadow-2xl hidden">
        <p class="font-semibold">Controls: **Gas:** Up Arrow (or Hold) | **Steer:** Left/Right Arrow</p>
    </div>

    <div id="pedals-container" class="absolute bottom-5 right-5 flex gap-5 z-20 hidden">
        <div id="brake-pedal" class="pedal w-20 h-24 bg-gray-600 text-white text-lg font-bold rounded-lg flex items-center justify-center">BRAKE</div> 
        <div id="gas-pedal" class="pedal w-20 h-24 bg-gray-600 text-white text-lg font-bold rounded-lg flex items-center justify-center">GAS</div>
    </div>
</div>

<div id="modal-container"></div>

<script>
    // --- THREE.JS SETUP & CONFIGURATION ---
    const CONTAINER = document.getElementById('canvas-3d');
    let scene, camera, renderer, clock, animationFrameId;

    // --- BASE GAME CONSTANTS ---
    const LANE_COUNT = 4;
    const ROAD_WIDTH = 6;
    const CAR_SIZE = { width: (ROAD_WIDTH / LANE_COUNT) * 0.7, height: 0.5, depth: 1.5 };
    // >> START ADDITION: TRUCK SIZE
    const TRUCK_SIZE = { width: (ROAD_WIDTH / LANE_COUNT) * 0.9, height: 1.0, depth: 3.0 }; // Wider and longer
    // >> END ADDITION
    const SPEED_UNIT_TO_MPH = 5.33; 
    
    // Fixed road color (Classic Road as requested)
    const CLASSIC_ROAD_COLOR = 0x222222; 
    
    // Physics and Speed constants (ADJUSTED FOR FASTER FEEL AND MORE BUFFER)
    const BASE_MAX_PLAYER_SPEED = 25.0; 
    const BASE_IDLE_PLAYER_SPEED = 10.0;  
    const BASE_TRAFFIC_SPEED = 6.0;    
    const BASE_ACCELERATION_RATE = 7.0; 
    const BASE_DECELERATION_RATE = 10.0; 
    const LEVEL_MULTIPLIER = 1.08; 

    // Depth and Positioning
    const ROAD_DEPTH = 150; 
    const PLAYER_Z = 3;    
    const DESPAWN_Z = 5;   
    const FAR_Z_SPAWN = -120; // Spawn further out
    const DETAIL_COUNT = 40; 
    
    // Traffic Intensity (ADJUSTED for smoother difficulty ramp)
    const BASE_SPAWN_INTERVAL = 0.55; // Increased from 0.45 
    const TRAFFIC_MULTIPLIER = 1.20; // Reduced from 1.35 (slower difficulty ramp)
    
    // **ADJUSTED:** Minimum required Z-gap for the longitudinal buffer (3.5 car lengths)
    const MIN_LONGITUDINAL_GAP = CAR_SIZE.depth * 3.5; 
    // **ADJUSTED:** Minimum required Z-gap for the lateral buffer (1.2 car lengths)
    const MIN_LATERAL_GAP = CAR_SIZE.depth * 1.2; 

    // --- ENVIRONMENT PRESETS ---
    const ENVIRONMENTS = [
        { name: "Sunny Meadow", skyColor: 0x87CEEB, fogNear: 0.4, fogFar: 0.8, grassColor: 0x38761d, foliageType: 'flowers', weather: 'none' }, 
        { name: "Autumn Dusk", skyColor: 0xcd6133, fogNear: 0.35, fogFar: 0.75, grassColor: 0x996515, foliageType: 'autumn', weather: 'none' }, 
        { name: "Heavy Rain", skyColor: 0x4d5656, fogNear: 0.15, fogFar: 0.5, grassColor: 0x3d3d3d, foliageType: 'wet', weather: 'rain' },
        { name: "Blizzard Drive", skyColor: 0xddeeff, fogNear: 0.1, fogFar: 0.4, grassColor: 0x99aaff, foliageType: 'snowy', weather: 'snow' },
        { name: "Night Ascent", skyColor: 0x1f2937, fogNear: 0.1, fogFar: 0.55, grassColor: 0x000000, foliageType: 'none', weather: 'none' },
    ];

    // --- GAME STATE ---
    let gameState = {
        score: 0,
        level: 1,
        playerSpeedUnits: BASE_IDLE_PLAYER_SPEED,
        isGameOver: false,
        isPaused: false,
        isGassing: false,
        lastTrafficSpawn: 0,
        traffic: [],
        backgroundElements: [],
        weatherParticles: null,
        currentEnvironmentIndex: 0,
        // >> START ADDITION: Keybindings
        keyBindings: {
            gas: 'ArrowUp',
            left: 'ArrowLeft',
            right: 'ArrowRight'
        },
        // >> END ADDITION
        playerCar: {
            mesh: null,
            lane: 1, 
            lanePositions: [], 
            targetX: 0,
            currentX: 0,
            moveSpeed: 12 
        }
    };
    
    // Dynamic Speed Variables
    let MAX_PLAYER_SPEED = BASE_MAX_PLAYER_SPEED;
    let IDLE_PLAYER_SPEED = BASE_IDLE_PLAYER_SPEED;
    let TRAFFIC_SPEED = BASE_TRAFFIC_SPEED;
    let ACCELERATION_RATE = BASE_ACCELERATION_RATE;
    let DECELERATION_RATE = BASE_DECELERATION_RATE;

    // --- UI Elements ---
    const infoPanelEl = document.getElementById('info-panel');
    const controlsInfoEl = document.getElementById('controls-info');
    const pedalsContainerEl = document.getElementById('pedals-container');
    const gasPedalEl = document.getElementById('gas-pedal');
    const brakePedalEl = document.getElementById('brake-pedal');
    const speedValueEl = document.getElementById('speed-value');
    const environmentNameEl = document.getElementById('environment-name');
    const modalContainerEl = document.getElementById('modal-container');
    const pauseButtonEl = document.getElementById('pause-button');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');

    // --- UTILITY AND 3D MESH GENERATION ---

    /** Calculates the center X position for each lane. */
    function calculateLanePositions() {
        const lanePositions = [];
        const laneWidth = ROAD_WIDTH / LANE_COUNT;
        const startX = -ROAD_WIDTH / 2; 
        for (let i = 0; i < LANE_COUNT; i++) {
            lanePositions.push(startX + i * laneWidth + laneWidth / 2);
        }
        gameState.playerCar.lanePositions = lanePositions;
    }

    /** Creates a generic car mesh (used for player and standard traffic) with body, cabin, and wheels. */
    function createGenericCarMesh(color) {
        const carGroup = new THREE.Group();
        const material = new THREE.MeshStandardMaterial({ color: color, metalness: 0.5, roughness: 0.5 });
        
        // Wheels (Determine size first to calculate offset)
        const wheelRadius = CAR_SIZE.width * 0.15;
        const bodyOffset = wheelRadius * 0.9; // A slight lift to integrate wheels visually

        // Main Body
        const mainBodyGeometry = new THREE.BoxGeometry(CAR_SIZE.width, CAR_SIZE.height, CAR_SIZE.depth);
        const mainBody = new THREE.Mesh(mainBodyGeometry, material);
        // --- FIX 1: Raise the car body to sit on top of the wheels ---
        mainBody.position.y = CAR_SIZE.height / 2 + bodyOffset; 
        // -------------------------------------------------------------
        carGroup.add(mainBody);

        // Cabin
        const cabinWidth = CAR_SIZE.width * 0.8;
        const cabinHeight = CAR_SIZE.height * 0.6;
        const cabinDepth = CAR_SIZE.depth * 0.6;
        const cabinGeometry = new THREE.BoxGeometry(cabinWidth, cabinHeight, cabinDepth);
        const cabinMaterial = new THREE.MeshStandardMaterial({ color: color - 0x111111, metalness: 0.3, roughness: 0.8 }); 
        
        const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
        // --- FIX 2: Raise the cabin by the same offset ---
        cabin.position.y = CAR_SIZE.height + cabinHeight / 2 + bodyOffset;
        // -------------------------------------------------
        cabin.position.z = -CAR_SIZE.depth * 0.1;
        carGroup.add(cabin);

        // Wheels (Simple cylinders)
        const wheelDepth = 0.1;
        const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelDepth, 8);
        const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 }); 
        
        const wheelPositions = [
            { x: CAR_SIZE.width * 0.45, z: CAR_SIZE.depth * 0.3 },
            { x: -CAR_SIZE.width * 0.45, z: CAR_SIZE.depth * 0.3 },
            { x: CAR_SIZE.width * 0.45, z: -CAR_SIZE.depth * 0.3 },
            { x: -CAR_SIZE.width * 0.45, z: -CAR_SIZE.depth * 0.3 },
        ];

        wheelPositions.forEach(pos => {
            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel.rotation.z = Math.PI / 2;
            // The position is correct: center at Y=radius means bottom touches Y=0
            wheel.position.set(pos.x, wheelRadius, pos.z);
            carGroup.add(wheel);
        });
        
        carGroup.children.forEach(child => {
            child.castShadow = true;
            child.receiveShadow = true;
        });
        carGroup.userData.isCar = true;
        carGroup.userData.carType = 'generic';
        carGroup.userData.collisionDepth = CAR_SIZE.depth;
        return carGroup;
    }

    /** Creates a truck mesh. */
    function createTruckMesh(color) {
        const carGroup = new THREE.Group();
        const material = new THREE.MeshStandardMaterial({ color: color, metalness: 0.3, roughness: 0.6 });
        
        // Wheels (Determine size first to calculate offset)
        const truckWheelRadius = CAR_SIZE.width * 0.2;
        const bodyOffset = truckWheelRadius * 0.9; // A slight lift to integrate wheels visually

        // Main Body (Box)
        const mainBodyGeometry = new THREE.BoxGeometry(TRUCK_SIZE.width, TRUCK_SIZE.height, TRUCK_SIZE.depth);
        const mainBody = new THREE.Mesh(mainBodyGeometry, material);
        // --- FIX 3: Raise the truck body to sit on top of the wheels ---
        mainBody.position.y = TRUCK_SIZE.height / 2 + bodyOffset;
        // -------------------------------------------------------------
        carGroup.add(mainBody);

        // Cabin (Smaller box on the front)
        const cabinWidth = TRUCK_SIZE.width * 0.8;
        const cabinHeight = TRUCK_SIZE.height * 0.6;
        const cabinDepth = TRUCK_SIZE.depth * 0.25;
        const cabinGeometry = new THREE.BoxGeometry(cabinWidth, cabinHeight, cabinDepth);
        const cabinMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.3, roughness: 0.8 }); 
        
        const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
        // --- FIX 4: Raise the truck cabin by the same offset ---
        cabin.position.y = TRUCK_SIZE.height + cabinHeight / 2 + bodyOffset; 
        // ------------------------------------------------------
        cabin.position.z = TRUCK_SIZE.depth * 0.3; // Position at the front
        carGroup.add(cabin);
        
        // Wheels (Adjusted for truck size)
        const wheelRadius = truckWheelRadius;
        const wheelDepth = 0.15;
        const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelDepth, 8);
        const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 }); 
        
        const wheelPositions = [
            { x: TRUCK_SIZE.width * 0.4, z: TRUCK_SIZE.depth * 0.4 },
            { x: -TRUCK_SIZE.width * 0.4, z: TRUCK_SIZE.depth * 0.4 },
            { x: TRUCK_SIZE.width * 0.4, z: -TRUCK_SIZE.depth * 0.4 },
            { x: -TRUCK_SIZE.width * 0.4, z: -TRUCK_SIZE.depth * 0.4 },
        ];

        wheelPositions.forEach(pos => {
            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel.rotation.z = Math.PI / 2;
            // The position is correct: center at Y=radius means bottom touches Y=0
            wheel.position.set(pos.x, wheelRadius, pos.z);
            carGroup.add(wheel);
        });

        carGroup.children.forEach(child => {
            child.castShadow = true;
            child.receiveShadow = true;
        });
        carGroup.userData.isCar = true;
        carGroup.userData.carType = 'truck';
        carGroup.userData.collisionDepth = TRUCK_SIZE.depth; // Set dynamic depth
        return carGroup;
    }

    /** Creates a car mesh (randomly selects between types for traffic, or always generic for player). */
    function createCarMesh(color, isPlayer = false) {
        if (isPlayer) {
            return createGenericCarMesh(color);
        }

        // Randomly choose car type for traffic
        const carTypes = [createGenericCarMesh, createTruckMesh];
        const weights = [80, 20]; // 80% generic car, 20% truck

        let totalWeight = 0;
        for (const weight of weights) { totalWeight += weight; }

        let random = Math.random() * totalWeight;
        let selectedType = createGenericCarMesh; // Default to generic

        for (let i = 0; i < carTypes.length; i++) {
            random -= weights[i];
            if (random < 0) {
                selectedType = carTypes[i];
                break;
            }
        }

        const mesh = selectedType(color);
        mesh.userData.isCar = true;
        return mesh;
    }


    /** Creates a background foliage mesh (tree, flower, or none). */
    function createBackgroundMesh(style, grassColor) {
        const detailGroup = new THREE.Group();
        detailGroup.userData.isBackgroundElement = true;
        
        if (style === 'none') {
            return detailGroup; // Return empty group for "night ascent"
        }

        const trunkColor = 0x7c4912;
        let topColor = grassColor; 

        // Simplified flower object (for performance)
        if (style === 'flowers') {
            const flowerColor = [0xFFC0CB, 0xFFA07A, 0x90EE90, 0xADD8E6][Math.floor(Math.random() * 4)];
            const geometry = new THREE.ConeGeometry(0.3, 0.4, 4);
            const material = new THREE.MeshBasicMaterial({ color: flowerColor });
            const flower = new THREE.Mesh(geometry, material);
            flower.position.y = 0.2;
            detailGroup.add(flower);
        } else {
            // Standard/Autumn/Snowy Tree
            const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: trunkColor, roughness: 1 }); 
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.3; 
            detailGroup.add(trunk);

            let topGeometry, topYPos;
            if (style === 'snowy' || style === 'wet') {
                topGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
                topYPos = 1.3;
                topColor = style === 'snowy' ? 0xffffff : grassColor + 0x111111;
            } else {
                topGeometry = new THREE.ConeGeometry(0.4, 1.2, 8);
                topYPos = 1.2;
                if (style === 'autumn') {
                    topColor = [0x992d00, 0xcc6600, 0x4d3200][Math.floor(Math.random() * 3)];
                }
            }

            const topMaterial = new THREE.MeshStandardMaterial({ color: topColor, metalness: 0, roughness: 0.7 }); 
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = topYPos; 
            detailGroup.add(top);
        }

        detailGroup.children.forEach(child => {
            child.castShadow = true;
            child.receiveShadow = true;
        });
        detailGroup.userData.isBackgroundElement = true;
        return detailGroup;
    }

    /** Creates and adds rain/snow particle systems. */
    function createWeatherParticleSystem(weatherType) {
        const particleCount = weatherType === 'rain' ? 2500 : 1800;
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const rainVolumeWidth = ROAD_WIDTH + 30;
        const zWrap = ROAD_DEPTH * 0.8;

        for (let i = 0; i < particleCount; i++) {
            // X: Wide range across the scene
            positions.push( (Math.random() - 0.5) * rainVolumeWidth ); 
            // Y: High above the road
            positions.push( 15 + Math.random() * 10 ); 
            // Z: Spread out along the road depth
            positions.push( FAR_Z_SPAWN + Math.random() * zWrap );
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

        let material;
        if (weatherType === 'rain') {
            material = new THREE.PointsMaterial({
                color: 0x99aaff,
                size: 0.15,
                transparent: true,
                opacity: 0.6,
            });
        } else if (weatherType === 'snow') {
            material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.35,
                transparent: true,
                opacity: 0.8,
            });
        }

        gameState.weatherParticles = new THREE.Points(geometry, material);
        gameState.weatherParticles.position.z = PLAYER_Z;
        gameState.weatherParticles.userData.isWeather = true;
        scene.add(gameState.weatherParticles);
    }

    /** Cleans up weather particle systems. */
    function cleanupWeather() {
        if (gameState.weatherParticles) {
            scene.remove(gameState.weatherParticles);
            gameState.weatherParticles.geometry?.dispose();
            gameState.weatherParticles.material?.dispose();
            gameState.weatherParticles = null;
        }
    }
    
    // --- SCENE INITIALIZATION ---

    /** Initializes the 3D scene, camera, and renderer. */
    function initThreeJS() {
        // Scene setup
        scene = new THREE.Scene();
        
        const initialEnv = ENVIRONMENTS[0];
        scene.fog = new THREE.Fog(initialEnv.skyColor, ROAD_DEPTH * initialEnv.fogNear, ROAD_DEPTH * initialEnv.fogFar);
        
        // Camera setup
        const initialWidth = window.innerWidth;
        const initialHeight = window.innerHeight;
        camera = new THREE.PerspectiveCamera(70, initialWidth / initialHeight, 0.1, ROAD_DEPTH + 50);
        // Slightly higher camera angle for better road visibility
        camera.position.set(0, 2.5, PLAYER_Z + 3.5); 
        camera.lookAt(0, 0.5, 0); // Look slightly down

        // Renderer setup
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(initialWidth, initialHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        CONTAINER.appendChild(renderer.domElement);

        window.addEventListener('resize', onWindowResize);
        clock = new THREE.Clock();

        // Lighting - Enhanced for better contrast and shadows
        // 1. Hemisphere Light (Soft ambient lighting)
        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
        scene.add(hemisphereLight);

        // 2. Directional Light (Sun/Headlight effect for shadows)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 30;
        scene.add(directionalLight);
    }
    
    /** Handles resizing the canvas and camera when the window size changes. */
    function onWindowResize() {
        if (!camera || !renderer) return;
        const newWidth = window.innerWidth;
        const newHeight = window.innerHeight;

        camera.aspect = newWidth / newHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(newWidth, newHeight);
    }
    
    /** Creates the static road and the animated lane markings. */
    function createRoad() {
        // 1. Road Surface (Fixed Classic Asphalt Color)
        const roadGeometry = new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_DEPTH, 1, 150); 
        const roadMaterial = new THREE.MeshLambertMaterial({ color: CLASSIC_ROAD_COLOR });
        const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
        roadMesh.rotation.x = -Math.PI / 2; 
        roadMesh.position.y = 0; 
        roadMesh.position.z = -ROAD_DEPTH / 2 + PLAYER_Z; 
        roadMesh.receiveShadow = true;
        roadMesh.userData.isRoad = true;
        scene.add(roadMesh);
        
        // 2. Lane Lines (White Dashes)
        const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const lineDepth = 1.2; 
        const lineGap = 1.8; 
        const totalPattern = lineDepth + lineGap;
        // Calculate needed number of lines based on depth
        const numLines = Math.ceil(ROAD_DEPTH / totalPattern) * 2; 
        
        for (let i = 1; i < LANE_COUNT; i++) {
            const xPos = gameState.playerCar.lanePositions[i] - ROAD_WIDTH / LANE_COUNT / 2;
            
            const lineGroup = new THREE.Group();
            lineGroup.userData.isLaneLine = true;
            
            for (let j = 0; j < numLines; j++) {
                const lineGeometry = new THREE.PlaneGeometry(0.15, lineDepth);
                const lineMesh = new THREE.Mesh(lineGeometry, lineMaterial);
                
                lineMesh.rotation.x = -Math.PI / 2;
                // Offset the starting Z position to ensure wrapping works smoothly
                lineMesh.position.set(xPos, 0.01, FAR_Z_SPAWN + j * totalPattern); 
                lineGroup.add(lineMesh);
            }
            lineGroup.userData.totalZExtent = numLines * totalPattern;
            scene.add(lineGroup);
        }

        // >> START ADDITION: Road Railings (Guardrails)
        const railingGeometry = new THREE.BoxGeometry(0.15, 0.4, ROAD_DEPTH); 
        const railingMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.3 }); 

        // 3. Left Railing
        const leftRailing = new THREE.Mesh(railingGeometry, railingMaterial);
        leftRailing.position.set(-ROAD_WIDTH / 2 - 0.5, 0.2, -ROAD_DEPTH / 2 + PLAYER_Z);
        leftRailing.receiveShadow = true;
        leftRailing.castShadow = true;
        leftRailing.userData.isRoadDetail = true;
        scene.add(leftRailing);
        
        // 4. Right Railing
        const rightRailing = new THREE.Mesh(railingGeometry, railingMaterial);
        rightRailing.position.set(ROAD_WIDTH / 2 + 0.5, 0.2, -ROAD_DEPTH / 2 + PLAYER_Z);
        rightRailing.receiveShadow = true;
        rightRailing.castShadow = true;
        rightRailing.userData.isRoadDetail = true;
        scene.add(rightRailing);
        // >> END ADDITION
    }

    // --- GAME LOGIC FUNCTIONS ---

    /** Applies the speed and traffic multipliers based on the current level. */
    function scaleGameSpeed() {
        const speedFactor = Math.pow(LEVEL_MULTIPLIER, gameState.level - 1); 

        MAX_PLAYER_SPEED = BASE_MAX_PLAYER_SPEED * speedFactor;
        IDLE_PLAYER_SPEED = BASE_IDLE_PLAYER_SPEED * speedFactor;
        TRAFFIC_SPEED = BASE_TRAFFIC_SPEED * speedFactor;
        ACCELERATION_RATE = BASE_ACCELERATION_RATE * speedFactor;
        DECELERATION_RATE = BASE_DECELERATION_RATE * speedFactor;
        
        gameState.playerSpeedUnits = Math.max(gameState.playerSpeedUnits, IDLE_PLAYER_SPEED);
    }

    /** Updates the scene's colors, fog, and light based on the current level/environment. */
    function updateEnvironment(newLevel) {
        // 1. Determine environment settings
        gameState.currentEnvironmentIndex = (newLevel - 1) % ENVIRONMENTS.length;
        const env = ENVIRONMENTS[gameState.currentEnvironmentIndex];

        // 2. Cleanup weather and background elements
        cleanupWeather(); 
        
        // 3. Apply general scene settings
        scene.background = new THREE.Color(env.skyColor);
        scene.fog.color.set(env.skyColor);
        scene.fog.near = ROAD_DEPTH * env.fogNear;
        scene.fog.far = ROAD_DEPTH * env.fogFar;

        // 4. Update Background Elements (clear and redraw with new style)
        createBackgroundElements(env.foliageType, env.grassColor);
        
        // 5. Spawn Weather Effects
        if (env.weather === 'rain' || env.weather === 'snow') {
            createWeatherParticleSystem(env.weather);
        }

        // 6. Update UI
        environmentNameEl.textContent = env.name;
    }

    /** Creates static background elements (grass/shoulders and wrapping trees/flowers). */
    let grassMesh;
    function createBackgroundElements(foliageType, grassColor) {
        // Remove old elements first
        for (let i = scene.children.length - 1; i >= 0; i--) {
            const child = scene.children[i];
            if (child.userData.isBackgroundElement) { 
                scene.remove(child);
                child.geometry?.dispose();
                child.material?.dispose();
            }
        }
        gameState.backgroundElements = [];
        
        // 1. Grass/Ground Plane 
        const grassGeometry = new THREE.PlaneGeometry(ROAD_WIDTH + 30, ROAD_DEPTH); 
        const grassMaterial = new THREE.MeshLambertMaterial({ color: grassColor });
        grassMesh = new THREE.Mesh(grassGeometry, grassMaterial);
        grassMesh.rotation.x = -Math.PI / 2;
        grassMesh.position.y = -0.05; 
        grassMesh.position.z = -ROAD_DEPTH / 2 + PLAYER_Z;
        grassMesh.receiveShadow = true;
        grassMesh.userData.isBackgroundElement = true; 
        scene.add(grassMesh);

        // 2. Foliage (Animated/Wrapping)
        for (let i = 0; i < DETAIL_COUNT; i++) {
            const detailGroup = createBackgroundMesh(foliageType, grassColor); 
            
            let xPos = ROAD_WIDTH / 2 + 3 + Math.random() * 8;
            if (Math.random() > 0.5) {
                xPos = -xPos; 
            }

            const zPos = FAR_Z_SPAWN + Math.random() * (ROAD_DEPTH + 30); 

            detailGroup.position.set(xPos, 0, zPos);
            detailGroup.rotation.y = Math.random() * Math.PI * 2;
            
            scene.add(detailGroup);
            gameState.backgroundElements.push(detailGroup);
        }
    }

    /** Creates a traffic car and adds it to the scene. */
    function createTrafficCar(lane) { 
        const trafficColors = [0xe74c3c, 0xf1c40f, 0x9b59b6, 0x1abc9c, 0xecf0f1, 0x34495e, 0x95a5a6]; 
        const carColor = trafficColors[Math.floor(Math.random() * trafficColors.length)];

        // Pass false for isPlayer
        const carMesh = createCarMesh(carColor, false);
        
        // Check which size we used to adjust the spawn position correctly
        const carDepth = carMesh.userData.collisionDepth;
        
        carMesh.position.set(
            gameState.playerCar.lanePositions[lane], 
            0, 
            FAR_Z_SPAWN + carDepth / 2 + Math.random() * 20 
        );

        carMesh.userData.lane = lane; // Re-assign userData after createCarMesh returns
        // >> START ADDITION: Traffic Behavior State
        carMesh.userData.targetLane = lane;
        carMesh.userData.moveSpeed = 8; // Speed for traffic lane change
        carMesh.userData.lastShiftTime = clock.getElapsedTime();
        // >> END ADDITION
        
        scene.add(carMesh);
        gameState.traffic.push(carMesh);
    }
    
    /** * Checks if spawning a car in a given lane adheres to the minimum separation rules.
     * Crucially checks for overlapping cars at the far spawn point.
     * @param {number} laneToSpawn - The lane index we are considering placing a new car.
     * @returns {boolean} True if it is safe to spawn, false otherwise.
     */
    function isSpawnSafe(laneToSpawn) {
        const currentLane = laneToSpawn;
        const spawnZ = FAR_Z_SPAWN; 
        
        // Find existing traffic that is close to the spawn point
        const relevantTraffic = gameState.traffic.filter(car => 
            car.position.z < PLAYER_Z + 10 // Only consider cars that haven't passed the player yet
        );
        
        for (const car of relevantTraffic) {
            const carZ = car.position.z;
            // Get the car's collision depth dynamically
            const carDepth = car.userData.collisionDepth || CAR_SIZE.depth;
            
            // 1. Same-Lane Check (Longitudinal Separation)
            if (car.userData.lane === currentLane) {
                // Check for immediate overlap (car spawning *inside* existing car)
                if (Math.abs(carZ - spawnZ) < carDepth * 0.5) {
                    return false; 
                }
                
                // Check if the car is too close to the front of the spawn point
                if (carZ - spawnZ < MIN_LONGITUDINAL_GAP && carZ - spawnZ > 0) {
                    return false; 
                }
            }
            
            // 2. Adjacent-Lane Check (Lateral Separation)
            const isAdjacent = Math.abs(car.userData.lane - currentLane) === 1;

            if (isAdjacent) {
                // Check if the adjacent car is too close longitudinally
                if (Math.abs(carZ - spawnZ) < MIN_LATERAL_GAP) {
                    return false;
                }
            }
        }
        
        // 3. Playability Check: Ensure a path remains (Don't spawn if all other lanes are blocked near Z=FAR_Z_SPAWN)
        const blockedLanes = new Set(); 
        
        for (const car of relevantTraffic) {
            // A lane is blocked if a car is within the generous longitudinal gap distance
            if (Math.abs(car.position.z - spawnZ) < MIN_LONGITUDINAL_GAP * 0.75) { 
                blockedLanes.add(car.userData.lane);
            }
        }
        
        // If all lanes are blocked, it's impossible to pass through the spawn zone.
        if (blockedLanes.size === LANE_COUNT) {
            return false;
        }

        return true; 
    }

    /**
     * Handles movement and behavior (lane shifting) for a single traffic car.
     * @param {THREE.Group} carMesh - The traffic car object.
     * @param {number} deltaTime - Time elapsed since the last frame.
     * @returns {boolean} True if a collision occurred with the player, false otherwise.
     */
    function updateTrafficCar(carMesh, deltaTime) {
        const { playerSpeedUnits, lanePositions } = gameState;
        const trafficRelativeMoveDistance = (playerSpeedUnits - TRAFFIC_SPEED) * deltaTime;
        
        // 1. Move Forward
        carMesh.position.z += trafficRelativeMoveDistance; 

        // 2. Lateral Movement (Smoothly move towards the target X position)
        const targetX = lanePositions[carMesh.userData.targetLane];

        carMesh.position.x += (targetX - carMesh.position.x) * carMesh.userData.moveSpeed * deltaTime;

        // If a shift is complete, lock the position and update the current lane
        if (Math.abs(carMesh.position.x - targetX) < 0.01) {
             carMesh.position.x = targetX;
             carMesh.userData.lane = carMesh.userData.targetLane;
        }

        // 3. Random Lane Change Initiation (only if not currently shifting)
        if (carMesh.userData.lane === carMesh.userData.targetLane) {
            const timeSinceLastShift = clock.getElapsedTime() - carMesh.userData.lastShiftTime;
            
            // Only try to shift if enough time has passed (randomly between 3-8 seconds)
            if (timeSinceLastShift > 3 + Math.random() * 5) { 
                
                // 10% chance to attempt a shift
                if (Math.random() < 0.1) {
                    
                    let newLane = carMesh.userData.lane;
                    const adjacentLanes = [];
                    if (newLane > 0) adjacentLanes.push(newLane - 1);
                    if (newLane < LANE_COUNT - 1) adjacentLanes.push(newLane + 1);

                    if (adjacentLanes.length > 0) {
                        const chosenLane = adjacentLanes[Math.floor(Math.random() * adjacentLanes.length)];
                        
                        // Basic Check: Prevent immediate collision with a car directly ahead in the target lane
                        let isBlocked = false;
                        const trafficCollisionDepth = carMesh.userData.collisionDepth || CAR_SIZE.depth; 
                        
                        // Check for a car within 3 car lengths ahead in the chosen lane
                        const futureZ = carMesh.position.z - trafficCollisionDepth * 3; 
                        
                        for (const otherCar of gameState.traffic) {
                            if (otherCar !== carMesh && otherCar.userData.lane === chosenLane) {
                                if (otherCar.position.z > futureZ && otherCar.position.z < carMesh.position.z) {
                                    isBlocked = true;
                                    break;
                                }
                            }
                        }

                        if (!isBlocked) {
                            carMesh.userData.targetLane = chosenLane;
                            carMesh.userData.lastShiftTime = clock.getElapsedTime();
                        }
                    }
                }
            }
        }

        // 4. Collision Check
        return checkCollision(gameState.playerCar.mesh, carMesh);
    }


    /** Moves and wraps all dynamic elements to create the infinite road effect. */
    function updateMotion(deltaTime) {
        const playerCar = gameState.playerCar;
        const { playerSpeedUnits, traffic } = gameState;

        // 1. Update Player Car Speed
        if (gameState.isGassing) {
            gameState.playerSpeedUnits = Math.min(MAX_PLAYER_SPEED, playerSpeedUnits + ACCELERATION_RATE * deltaTime);
            gasPedalEl.classList.add('active', 'bg-green-500');
            brakePedalEl.classList.remove('active', 'bg-red-500');
            
        } else {
            if (playerSpeedUnits > IDLE_PLAYER_SPEED) {
                gameState.playerSpeedUnits = Math.max(IDLE_PLAYER_SPEED, playerSpeedUnits - DECELERATION_RATE * deltaTime);
            }
            gasPedalEl.classList.remove('active', 'bg-green-500');
            brakePedalEl.classList.add('active', 'bg-red-500');
        }

        // 2. Player Car Lane Change (Smooth movement)
        playerCar.currentX += (playerCar.targetX - playerCar.currentX) * playerCar.moveSpeed * deltaTime;
        playerCar.mesh.position.x = playerCar.currentX;

        // 3. Motion Calculations
        const roadMoveDistance = playerSpeedUnits * deltaTime;
        
        // 4. Move and Check Traffic Cars
        for (let i = traffic.length - 1; i >= 0; i--) {
            const carMesh = traffic[i];
            
            // >> START UPDATE: Use the dedicated function for movement, behavior, and collision
            if (updateTrafficCar(carMesh, deltaTime)) {
                gameState.isGameOver = true;
                showGameOverScreen();
                return;
            }
            // >> END UPDATE

            if (carMesh.position.z > DESPAWN_Z) {
                scene.remove(carMesh);
                traffic.splice(i, 1);
            }
        }

        // 5. Handle Traffic Spawning 
        gameState.lastTrafficSpawn += deltaTime;
        const requiredTime = BASE_SPAWN_INTERVAL / Math.pow(TRAFFIC_MULTIPLIER, gameState.level - 1); 

        if (gameState.lastTrafficSpawn > requiredTime) {
            let newLane = Math.floor(Math.random() * LANE_COUNT);
            let attempts = 0;
            const maxAttempts = LANE_COUNT * 2; 

            // Loop to find a safe lane to spawn in
            while (!isSpawnSafe(newLane) && attempts < maxAttempts) {
                newLane = (newLane + 1) % LANE_COUNT; // Cycle to the next lane
                attempts++;
            }

            // Only spawn if a safe lane was found within attempts
            if (isSpawnSafe(newLane)) {
                createTrafficCar(newLane);
            }
            
            gameState.lastTrafficSpawn = 0; 
        }

        // 6. Move Lane Lines and Background Elements (Infinite Road Effect)
        scene.children.forEach(child => {
            if (child.userData.isLaneLine) {
                const totalZExtent = child.userData.totalZExtent;
                child.children.forEach(line => {
                    line.position.z += roadMoveDistance; 
                    if (line.position.z > PLAYER_Z + line.geometry.parameters.height) { 
                        line.position.z -= totalZExtent; 
                    }
                });
            } else if (child.userData.isBackgroundElement && child !== grassMesh) {
                child.position.z += roadMoveDistance; 
                if (child.position.z > DESPAWN_Z) {
                    child.position.z -= ROAD_DEPTH + 30; // Wrap back to the far end
                }
            }
        });
        
        // 7. Update Weather Particles
        updateWeatherParticles(deltaTime);
    }
    
    /** Animates and wraps the rain/snow particles. */
    function updateWeatherParticles(deltaTime) {
        if (!gameState.weatherParticles) return;

        const env = ENVIRONMENTS[gameState.currentEnvironmentIndex];
        const positions = gameState.weatherParticles.geometry.attributes.position.array;
        const speedFactor = (gameState.playerSpeedUnits * 0.02); 
        
        let particleSpeed = 0; 
        let yOffset = 0;
        const zWrap = ROAD_DEPTH * 0.8;

        if (env.weather === 'rain') {
            particleSpeed = 100 * deltaTime + speedFactor; 
            yOffset = -50 * deltaTime;
        } else if (env.weather === 'snow') {
            particleSpeed = 20 * deltaTime + speedFactor; 
            yOffset = -5 * deltaTime;
        }

        for (let i = 0; i < positions.length; i += 3) {
            positions[i + 2] += particleSpeed;
            positions[i + 1] += yOffset; 
            
            // Add slight horizontal drift for effect
            positions[i] += Math.sin(positions[i + 2] * 0.1 + clock.getElapsedTime() * 0.5) * 0.05 * deltaTime * 60;

            // Wrap Z position
            if (positions[i + 2] > PLAYER_Z + 5) {
                positions[i + 2] -= zWrap;
                positions[i + 1] = 15 + Math.random() * 10;
            }
            
            // Wrap Y position
            if (positions[i + 1] < 0) {
                positions[i + 1] = 15 + Math.random() * 10;
            }
        }

        gameState.weatherParticles.geometry.attributes.position.needsUpdate = true;
    }

    /** Checks for collision between player car and traffic car (AABB simple check) */
    function checkCollision(player, trafficMesh) {
        const playerZ = PLAYER_Z; 
        const trafficZ = trafficMesh.position.z;
        const halfWidth = CAR_SIZE.width / 2;
        const halfDepth = CAR_SIZE.depth / 2;
        
        // Use the car's dynamic collision depth (set in createCarMesh/createTruckMesh)
        const trafficCollisionDepth = trafficMesh.userData.collisionDepth || CAR_SIZE.depth; 
        const trafficHalfDepth = trafficCollisionDepth / 2; 

        // 1. X-axis overlap check (simple check for same lane)
        const playerMinX = player.position.x - halfWidth * 0.9; 
        const playerMaxX = player.position.x + halfWidth * 0.9;
        const trafficMinX = trafficMesh.position.x - halfWidth * 0.9;
        const trafficMaxX = trafficMesh.position.x + halfWidth * 0.9;

        const xOverlap = Math.max(0, Math.min(playerMaxX, trafficMaxX) - Math.max(playerMinX, trafficMinX));

        if (xOverlap > CAR_SIZE.width * 0.1) {
            // 2. Z-axis overlap
            const playerFrontZ = playerZ + halfDepth;
            const playerBackZ = playerZ - halfDepth;
            
            // Use trafficHalfDepth for traffic car
            const trafficFrontZ = trafficZ + trafficHalfDepth;
            const trafficBackZ = trafficZ - trafficHalfDepth;

            // Use a slight tolerance to ensure the collision is forgiving but solid
            if (playerFrontZ > trafficBackZ + 0.1 && playerBackZ < trafficFrontZ - 0.1) {
                return true;
            }
        }
        return false;
    }


    /** Updates UI elements and checks for level progression. */
    function updateUI(deltaTime) {
        const { score, level, playerSpeedUnits } = gameState;
        
        // Score update
        gameState.score += playerSpeedUnits * deltaTime * 10; 
        scoreEl.textContent = Math.floor(gameState.score);
        
        // Speed update
        speedValueEl.textContent = Math.floor(playerSpeedUnits * SPEED_UNIT_TO_MPH);

        // Level check
        const newLevel = Math.floor(score / 3500) + 1; // Slightly increased score needed for next level
        if (newLevel > level) {
            gameState.level = newLevel;
            levelEl.textContent = gameState.level;
            scaleGameSpeed(); 
            updateEnvironment(gameState.level); 
        }
    }


    // --- GAME CONTROL FUNCTIONS ---
    
    // >> START ADDITION: Keybinding Functions
    /** Global function to update keybindings from the settings menu. */
    window.updateKeybinding = function(action, elementId) {
        const button = document.getElementById(elementId);
        const originalText = button.textContent;
        button.textContent = 'Press a key...';
        
        const handler = (e) => {
            const newKey = e.key;
            
            // Check for duplicate keys (prevent same key for different actions)
            for (const key in gameState.keyBindings) {
                if (key !== action && gameState.keyBindings[key] === newKey) {
                    alert(`Key '${newKey}' is already used for ${key.toUpperCase()}.`);
                    button.textContent = originalText; // Revert to current key
                    document.removeEventListener('keydown', handler);
                    return;
                }
            }

            gameState.keyBindings[action] = newKey;
            button.textContent = newKey;

            // Update controls info immediately if visible
            updateControlsInfo(); 
            
            document.removeEventListener('keydown', handler);
        };

        // Temporarily remove focus from the button to ensure keydown is captured on the document
        button.blur(); 
        
        // Remove old listener if any and add new one
        document.removeEventListener('keydown', handler);
        document.addEventListener('keydown', handler, { once: true });
    };

    /** Updates the on-screen controls info with the current keybindings. */
    function updateControlsInfo() {
        const gasKey = gameState.keyBindings.gas;
        const leftKey = gameState.keyBindings.left;
        const rightKey = gameState.keyBindings.right;
        
        const gasDisplay = gasKey === ' ' ? 'Spacebar' : gasKey;
        const leftDisplay = leftKey === ' ' ? 'Spacebar' : leftKey;
        const rightDisplay = rightKey === ' ' ? 'Spacebar' : rightKey;

        controlsInfoEl.innerHTML = `<p class="font-semibold">Controls: **Gas:** ${gasDisplay} (or Hold) | **Steer:** ${leftDisplay}/${rightDisplay}</p>`;
    }
    // >> END ADDITION: Keybinding Functions


    /** Shows the main menu screen. */
    function showMainMenu() {
        // Ensure UI elements are hidden
        infoPanelEl.classList.add('hidden');
        controlsInfoEl.classList.add('hidden');
        pedalsContainerEl.classList.add('hidden');
        
        // Clear old scene items (if any are left from a crash/restart)
        for (let i = scene.children.length - 1; i >= 0; i--) {
            const child = scene.children[i];
            // >> START ADDITION: Include road details in cleanup
            if (child.userData.isCar || child.userData.isLaneLine || child.userData.isRoad || child.userData.isBackgroundElement || child.userData.isWeather || child.userData.isRoadDetail) {
            // >> END ADDITION
                scene.remove(child);
                child.geometry?.dispose();
                child.material?.dispose();
            }
        }

        modalContainerEl.innerHTML = `
            <div class="modal-overlay">
                <div class="menu-card rounded-2xl p-8 md:p-12 text-center text-white w-11/12 md:w-96">
                    <h1 class="text-6xl font-extrabold mb-4 text-yellow-400 tracking-wider shadow-white">RADIAL RACE</h1>
                    <p class="text-xl text-gray-300 mb-8">Endless high-speed highway action.</p>
                    
                    <div class="space-y-4">
                        <button onclick="startGame()" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-4 rounded-lg shadow-lg transition duration-200 text-xl tracking-wider">
                            START RACE
                        </button>
                        <button onclick="showHowToPlay()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg shadow-md transition duration-200">
                            HOW TO PLAY
                        </button>
                        <button onclick="showSettingsMenu()" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 rounded-lg shadow-md transition duration-200">
                            SETTINGS (Keybinds)
                        </button>
                        </div>
                </div>
            </div>
        `;
    }

    /** Shows the instructions modal. */
    window.showHowToPlay = function() {
        modalContainerEl.innerHTML = `
            <div class="modal-overlay">
                <div class="menu-card rounded-2xl p-8 md:p-12 text-white w-11/12 md:w-1/3">
                    <h2 class="text-4xl font-extrabold mb-4 text-blue-400 text-center">HOW TO PLAY</h2>
                    
                    <div class="flex-shrink-0"> 
                        <ul class="list-none space-y-4 text-lg text-left">
                            <li class="p-3 bg-gray-700 rounded-lg">
                                <span class="font-bold text-green-300">ACCELERATE:</span> Hold the <span class="font-mono bg-gray-800 px-2 py-1 rounded">GAS Key (${gameState.keyBindings.gas})</span> to increase speed. Release to slow down.
                            </li>
                            <li class="p-3 bg-gray-700 rounded-lg">
                                <span class="font-bold text-yellow-300">STEERING:</span> Use <span class="font-mono bg-gray-800 px-2 py-1 rounded">LEFT Key (${gameState.keyBindings.left})</span> / <span class="font-mono bg-gray-800 px-2 py-1 rounded">RIGHT Key (${gameState.keyBindings.right})</span> to switch lanes.
                            </li>
                            <li class="p-3 bg-gray-700 rounded-lg">
                                <span class="font-bold text-red-300">OBJECTIVE:</span> Avoid traffic. Your score is based on distance traveled at speed.
                            </li>
                            <li class="p-3 bg-gray-700 rounded-lg">
                                <span class="font-bold text-indigo-300">PAUSE:</span> Press the <span class="font-mono bg-gray-800 px-2 py-1 rounded">SPACEBAR</span> at any time.
                            </li>
                        </ul>
                    </div>

                    <button onclick="showMainMenu()" class="mt-8 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 rounded-lg transition duration-200">BACK TO MENU</button>
                </div>
            </div>
        `;
    }

    // >> START ADDITION: Settings Menu Function
    /** Shows the settings menu modal for keybinding customization. */
    window.showSettingsMenu = function() {
        modalContainerEl.innerHTML = `
            <div class="modal-overlay">
                <div class="menu-card rounded-2xl p-8 md:p-12 text-white w-11/12 md:w-1/3">
                    <h2 class="text-4xl font-extrabold mb-6 text-purple-400 text-center">GAME SETTINGS</h2>
                    
                    <h3 class="text-2xl font-bold mb-4 text-gray-200">Key Bindings</h3>

                    <div class="space-y-4">
                        <div class="flex justify-between items-center p-3 bg-gray-700 rounded-lg">
                            <span class="font-bold text-green-300">Gas/Accelerate:</span>
                            <button id="keybind-gas" onclick="updateKeybinding('gas', 'keybind-gas')" class="bg-gray-900 hover:bg-gray-800 text-yellow-300 font-mono py-2 px-4 rounded transition duration-150 text-base">
                                ${gameState.keyBindings.gas}
                            </button>
                        </div>
                        <div class="flex justify-between items-center p-3 bg-gray-700 rounded-lg">
                            <span class="font-bold text-yellow-300">Steer Left:</span>
                            <button id="keybind-left" onclick="updateKeybinding('left', 'keybind-left')" class="bg-gray-900 hover:bg-gray-800 text-yellow-300 font-mono py-2 px-4 rounded transition duration-150 text-base">
                                ${gameState.keyBindings.left}
                            </button>
                        </div>
                        <div class="flex justify-between items-center p-3 bg-gray-700 rounded-lg">
                            <span class="font-bold text-yellow-300">Steer Right:</span>
                            <button id="keybind-right" onclick="updateKeybinding('right', 'keybind-right')" class="bg-gray-900 hover:bg-gray-800 text-yellow-300 font-mono py-2 px-4 rounded transition duration-150 text-base">
                                ${gameState.keyBindings.right}
                            </button>
                        </div>
                    </div>

                    <p class="text-sm text-gray-400 mt-4 text-center">Click a button above, then press the key you want to use.</p>

                    <button onclick="showMainMenu()" class="mt-8 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 rounded-lg transition duration-200">BACK TO MENU</button>
                </div>
            </div>
        `;
    }
    // >> END ADDITION: Settings Menu Function


    /** Toggles the game's paused state and shows the modal. */
    window.togglePause = function() {
        if (gameState.isGameOver) return; 

        gameState.isPaused = !gameState.isPaused;

        if (gameState.isPaused) {
            pauseButtonEl.textContent = 'RESUME (Space)';
            modalContainerEl.innerHTML = `
                <div class="modal-overlay">
                    <div class="menu-card rounded-xl p-10 text-center text-white shadow-2xl z-50 w-11/12 md:w-1/3">
                        <h2 class="text-4xl font-extrabold mb-4 text-yellow-400">GAME PAUSED</h2>
                        <p class="text-lg mb-6">Take a breath. Press 'RESUME' or the Spacebar to get back on the road.</p>
                        <button onclick="togglePause()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition duration-200">RESUME</button>
                    </div>
                </div>
            `;
            cancelAnimationFrame(animationFrameId);
        } else {
            pauseButtonEl.textContent = 'PAUSE (Space)';
            modalContainerEl.innerHTML = '';
            gameLoop();
        }
    }

    /** Displays the Game Over modal */
    function showGameOverScreen() {
        modalContainerEl.innerHTML = `
            <div class="modal-overlay">
                <div class="menu-card bg-red-900 border-2 border-red-500 rounded-xl p-10 text-center text-white shadow-2xl z-50 w-11/12 md:w-1/3">
                    <h2 class="text-5xl font-extrabold mb-4 text-red-300">CRASH! GAME OVER!</h2>
                    <p class="text-2xl mb-6">Final Score: <span class="text-yellow-400 font-extrabold">${Math.floor(gameState.score)}</span></p>
                    <button onclick="showMainMenu()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-200">BACK TO MENU</button>
                </div>
            </div>
        `;
        pauseButtonEl.textContent = 'CRASHED';
        cancelAnimationFrame(animationFrameId);
        // Hide game UI when game is over
        infoPanelEl.classList.add('hidden');
        controlsInfoEl.classList.add('hidden');
        pedalsContainerEl.classList.add('hidden');
    }
    
    /** Resets the game state and initializes all objects for a new game. */
    window.startGame = function() {
        // Clear all scene dynamic items 
        for (let i = scene.children.length - 1; i >= 0; i--) {
            const child = scene.children[i];
            // >> START UPDATE: Cleanup now includes isRoadDetail
            if (child.userData.isCar || child.userData.isLaneLine || child.userData.isRoad || child.userData.isBackgroundElement || child.userData.isWeather || child.userData.isRoadDetail) {
            // >> END UPDATE
                scene.remove(child);
                child.geometry?.dispose();
                child.material?.dispose();
            }
        }
        
        // Reset state variables
        gameState.score = 0;
        gameState.level = 1;
        gameState.isGameOver = false;
        gameState.isPaused = false;
        gameState.traffic = [];
        gameState.backgroundElements = [];
        gameState.lastTrafficSpawn = 0;
        cleanupWeather(); 

        scaleGameSpeed(); 
        gameState.playerSpeedUnits = IDLE_PLAYER_SPEED;
        
        // Setup lanes if first run
        if (gameState.playerCar.lanePositions.length === 0) {
            calculateLanePositions();
        }

        // Create player car (distinct blue) - Use the isPlayer flag to ensure it's a generic car
        gameState.playerCar.mesh = createCarMesh(0x3498db, true); 
        gameState.playerCar.lane = 1;
        gameState.playerCar.mesh.position.set(gameState.playerCar.lanePositions[gameState.playerCar.lane], 0, PLAYER_Z);
        gameState.playerCar.targetX = gameState.playerCar.lanePositions[gameState.playerCar.lane];
        gameState.playerCar.currentX = gameState.playerCar.lanePositions[gameState.playerCar.lane];
        scene.add(gameState.playerCar.mesh);

        // Rebuild static scene elements
        createRoad();
        updateEnvironment(1); 
        
        // Update UI visibility
        infoPanelEl.classList.remove('hidden');
        controlsInfoEl.classList.remove('hidden');
        pedalsContainerEl.classList.remove('hidden');
        scoreEl.textContent = 0;
        levelEl.textContent = 1;
        modalContainerEl.innerHTML = '';
        pauseButtonEl.textContent = 'PAUSE (Space)';
        
        // >> START ADDITION: Initialize controls info
        updateControlsInfo(); 
        // >> END ADDITION

        // Reset pedal visuals
        gasPedalEl.classList.remove('active', 'bg-green-500');
        brakePedalEl.classList.add('active', 'bg-red-500'); 
        
        clock.start();
        gameLoop();
    }


    // --- MAIN GAME LOOP ---

    function gameLoop() {
        if (gameState.isGameOver || gameState.isPaused) {
            cancelAnimationFrame(animationFrameId);
            return;
        }
        
        const deltaTime = clock.getDelta(); 
        
        // 1. Update all game physics and movement
        updateMotion(deltaTime);
        
        // 2. Update all UI displays and check for progression
        updateUI(deltaTime);

        // 3. Render the 3D scene
        renderer.render(scene, camera);

        animationFrameId = requestAnimationFrame(gameLoop);
    }


    // --- INPUT HANDLING ---

    document.addEventListener('keydown', (e) => {
        if (gameState.isGameOver) return;
        
        // Spacebar is always pause/resume regardless of keybindings
        if (e.key === ' ' || e.key === 'Spacebar') {
            e.preventDefault();
            togglePause();
            return;
        }

        if (gameState.isPaused) return;

        let newLane = gameState.playerCar.lane;

        // >> START UPDATED KEYBINDINGS (with e.preventDefault() for better control)
        if (e.key === gameState.keyBindings.left) {
            newLane = Math.max(0, gameState.playerCar.lane - 1);
            e.preventDefault();
        } else if (e.key === gameState.keyBindings.right) {
            newLane = Math.min(LANE_COUNT - 1, gameState.playerCar.lane + 1);
            e.preventDefault();
        } else if (e.key === gameState.keyBindings.gas) {
            gameState.isGassing = true;
            e.preventDefault();
        } else if (e.key === 'ArrowDown') { // Always allow ArrowDown as a universal 'brake' key
            gameState.isGassing = false; 
            e.preventDefault();
        }
        // >> END UPDATED KEYBINDINGS
        
        if (newLane !== gameState.playerCar.lane) {
            gameState.playerCar.lane = newLane;
            gameState.playerCar.targetX = gameState.playerCar.lanePositions[newLane];
        }
    });
    
    document.addEventListener('keyup', (e) => {
        // >> START UPDATED KEYBINDINGS
        if (e.key === gameState.keyBindings.gas) {
            gameState.isGassing = false;
        }
        // >> END UPDATED KEYBINDINGS
    });

    // --- INITIALIZATION ---

    // Start the game by showing the main menu
    window.onload = function () {
        initThreeJS();
        showMainMenu(); 
    }
</script>

</body>
</html>
