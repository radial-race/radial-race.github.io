<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Highway Racer with Main Menu</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        /* Custom CSS for 3D elements and layout control */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1f2937; /* Dark background */
        }
        
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        #canvas-3d {
            /* The canvas will be appended here and set to full screen by JS */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Basic styling for the 'pedal' visualizers */
        .pedal {
            box-shadow: 0 5px 0 0 #374151; /* Darker shadow for 3D effect */
            transition: box-shadow 0.1s, transform 0.1s;
        }

        .pedal.active {
            box-shadow: 0 2px 0 0 #374151;
            transform: translateY(3px);
        }

        /* Custom speed display styling */
        .speedometer {
            background: linear-gradient(145deg, #1f2937, #111827);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            border: 2px solid #374151;
        }

        /* Modal styling to ensure it covers everything */
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100; /* Highest z-index */
        }
        
        .menu-card {
            background: linear-gradient(135deg, #2d3748, #1a202c);
            border: 4px solid #4a5568;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            max-height: 90vh; 
            overflow-y: auto;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="canvas-3d"></div> 
    
    <div id="info-panel" class="absolute top-0 left-0 right-0 flex justify-between items-center p-4 text-white bg-gray-900 bg-opacity-80 z-20 shadow-lg hidden">
        
        <div id="speed-display" class="speedometer p-3 rounded-xl flex flex-col items-center">
            <span class="text-xs font-semibold text-gray-400">MPH</span>
            <span id="speed-value" class="text-3xl font-extrabold text-green-400">0</span>
        </div>
        
        <div class="text-center">
            <div class="text-2xl font-bold">Score: <span id="score">0</span></div>
            <div class="text-lg text-gray-400">Level: <span id="level">1</span> (<span id="environment-name">Sunny Meadow</span>)</div>
            <div class="text-sm text-yellow-300 font-semibold">High Score: <span id="high-score-display">0</span></div>
        </div>

        <button id="pause-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-xl transition duration-150" onclick="togglePause()">PAUSE (Space)</button>
    </div>
    
    <div id="controls-info" class="absolute bottom-24 md:bottom-32 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-gray-300 text-base md:text-lg text-center p-2 bg-gray-900 bg-opacity-70 rounded-lg z-20 shadow-2xl hidden">
        <p class="font-semibold">Controls: **Gas:** Up Arrow (or Hold) | **Steer:** Left/Right Arrow</p>
    </div>

    <div id="near-miss-display" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 text-5xl font-extrabold text-red-500 opacity-0 transition-opacity duration-300 z-30 pointer-events-none">
        NEAR MISS! X2
    </div>

    <div id="pedals-container" class="absolute bottom-5 right-5 flex gap-5 z-20 hidden">
        <div id="brake-pedal" class="pedal w-20 h-24 bg-gray-600 text-white text-lg font-bold rounded-lg flex items-center justify-center">BRAKE</div> 
        <div id="gas-pedal" class="pedal w-20 h-24 bg-gray-600 text-white text-lg font-bold rounded-lg flex items-center justify-center">GAS</div>
    </div>
</div>

<div id="modal-container"></div>

<script>
    // --- THREE.JS SETUP & CONFIGURATION ---
    const CONTAINER = document.getElementById('canvas-3d');
    let scene, camera, renderer, clock, animationFrameId;

    // --- BASE GAME CONSTANTS ---
    const LANE_COUNT = 4;
    const ROAD_WIDTH = 6;
    const CAR_SIZE = { width: (ROAD_WIDTH / LANE_COUNT) * 0.7, height: 0.5, depth: 1.5 };
    const TRUCK_SIZE = { width: (ROAD_WIDTH / LANE_COUNT) * 0.9, height: 1.0, depth: 3.0 }; // Wider and longer
    // Detail 5: Van Size
    const VAN_SIZE = { width: (ROAD_WIDTH / LANE_COUNT) * 0.8, height: 0.8, depth: 2.5 }; 
    const SPEED_UNIT_TO_MPH = 5.33; 
    
    const CLASSIC_ROAD_COLOR = 0x222222; 
    
    // Physics and Speed constants (ADJUSTED FOR FASTER FEEL AND MORE BUFFER)
    const BASE_MAX_PLAYER_SPEED = 25.0; 
    const BASE_IDLE_PLAYER_SPEED = 10.0;  
    const BASE_TRAFFIC_SPEED = 6.0;    
    const BASE_ACCELERATION_RATE = 7.0; 
    const BASE_DECELERATION_RATE = 10.0; 
    const LEVEL_MULTIPLIER = 1.08; 
    
    // Detail 1: Traffic AI Constants
    const TRAFFIC_LANE_CHANGE_RATE = 0.5; // How fast traffic moves sideways
    const TRAFFIC_CHANGE_DECISION_INTERVAL = 3.0; // Seconds between AI deciding to change lane
    const BLINKER_INTERVAL = 0.25; // Blinker flash speed

    // Depth and Positioning
    const ROAD_DEPTH = 150; 
    const PLAYER_Z = 3;    
    const DESPAWN_Z = 5;   
    const FAR_Z_SPAWN = -120; // Spawn further out
    const DETAIL_COUNT = 40; 
    
    // Traffic Intensity (ADJUSTED for smoother difficulty ramp)
    const BASE_SPAWN_INTERVAL = 0.55; 
    const TRAFFIC_MULTIPLIER = 1.20; 
    
    // Collision and Near-Miss constants
    const MIN_LONGITUDINAL_GAP = CAR_SIZE.depth * 3.5; 
    const MIN_LATERAL_GAP = CAR_SIZE.depth * 1.2; 
    // Detail 19: Near-miss distance (narrowly avoiding a crash)
    const NEAR_MISS_DISTANCE = CAR_SIZE.depth * 1.8; 
    const NEAR_MISS_SCORE_MULTIPLIER = 2.0;

    // --- ENVIRONMENT PRESETS ---
    // Detail 18: Added Coastal Sunset environment
    const ENVIRONMENTS = [
        { name: "Sunny Meadow", skyColor: 0x87CEEB, fogNear: 0.4, fogFar: 0.8, grassColor: 0x38761d, foliageType: 'flowers', weather: 'none' }, 
        { name: "Autumn Dusk", skyColor: 0xcd6133, fogNear: 0.35, fogFar: 0.75, grassColor: 0x996515, foliageType: 'autumn', weather: 'none' }, 
        { name: "Heavy Rain", skyColor: 0x4d5656, fogNear: 0.15, fogFar: 0.5, grassColor: 0x3d3d3d, foliageType: 'wet', weather: 'rain' },
        { name: "Blizzard Drive", skyColor: 0xddeeff, fogNear: 0.1, fogFar: 0.4, grassColor: 0x99aaff, foliageType: 'snowy', weather: 'snow' },
        { name: "Night Ascent", skyColor: 0x1f2937, fogNear: 0.1, fogFar: 0.55, grassColor: 0x000000, foliageType: 'lights', weather: 'none' },
        { name: "Coastal Sunset", skyColor: 0xffa07a, fogNear: 0.25, fogFar: 0.65, grassColor: 0x6b8e23, foliageType: 'sparse', weather: 'none' },
    ];

    // --- GAME STATE ---
    let gameState = {
        score: 0,
        level: 1,
        playerSpeedUnits: BASE_IDLE_PLAYER_SPEED,
        isGameOver: false,
        isPaused: false,
        isGassing: false,
        lastTrafficSpawn: 0,
        traffic: [],
        backgroundElements: [],
        weatherParticles: null,
        currentEnvironmentIndex: 0,
        keyBindings: {
            gas: 'ArrowUp',
            left: 'ArrowLeft',
            right: 'ArrowRight'
        },
        playerCar: {
            mesh: null,
            lane: 1, 
            lanePositions: [], 
            targetX: 0,
            currentX: 0,
            moveSpeed: 12 
        },
        // Detail 12: High Score
        highScore: localStorage.getItem('radialRacerHighScore') ? parseInt(localStorage.getItem('radialRacerHighScore')) : 0,
        // Detail 19: Near-Miss Timer
        nearMissTimer: 0,
        currentScoreMultiplier: 1.0,
        lastBlinkerToggle: 0 // Detail 3: Blinker timer
    };
    
    // Dynamic Speed Variables
    let MAX_PLAYER_SPEED = BASE_MAX_PLAYER_SPEED;
    let IDLE_PLAYER_SPEED = BASE_IDLE_PLAYER_SPEED;
    let TRAFFIC_SPEED = BASE_TRAFFIC_SPEED;
    let ACCELERATION_RATE = BASE_ACCELERATION_RATE;
    let DECELERATION_RATE = BASE_DECELERATION_RATE;

    // --- UI Elements ---
    const infoPanelEl = document.getElementById('info-panel');
    const controlsInfoEl = document.getElementById('controls-info');
    const pedalsContainerEl = document.getElementById('pedals-container');
    const gasPedalEl = document.getElementById('gas-pedal');
    const brakePedalEl = document.getElementById('brake-pedal');
    const speedValueEl = document.getElementById('speed-value');
    const environmentNameEl = document.getElementById('environment-name');
    const modalContainerEl = document.getElementById('modal-container');
    const pauseButtonEl = document.getElementById('pause-button');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const highScoreDisplayEl = document.getElementById('high-score-display');
    const nearMissDisplayEl = document.getElementById('near-miss-display');

    // --- UTILITY AND 3D MESH GENERATION ---
    highScoreDisplayEl.textContent = gameState.highScore; // Initialize high score display

    /** Calculates the center X position for each lane. */
    function calculateLanePositions() {
        const lanePositions = [];
        const laneWidth = ROAD_WIDTH / LANE_COUNT;
        const startX = -ROAD_WIDTH / 2; 
        for (let i = 0; i < LANE_COUNT; i++) {
            lanePositions.push(startX + i * laneWidth + laneWidth / 2);
        }
        gameState.playerCar.lanePositions = lanePositions;
    }
    
    // --- Detail Functions for Cars (Lights, Wheels) ---
    const headlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffaa });
    const taillightMaterial = new THREE.MeshBasicMaterial({ color: 0xcc0000 });
    const blinkerMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500, transparent: true, opacity: 0.8 });
    const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 }); 
    const wheelGeometry = new THREE.CylinderGeometry(CAR_SIZE.width * 0.15, CAR_SIZE.width * 0.15, 0.1, 8);
    wheelGeometry.rotateZ(Math.PI / 2);

    /** Adds light meshes and wheels to a car group. */
    function addDetails(carGroup, size, depthOffset = 0) {
        // Detail 6, 7: Lights
        const lightGeo = new THREE.BoxGeometry(size.width * 0.1, size.height * 0.1, 0.05);

        // Headlights (Front)
        const hlL = new THREE.Mesh(lightGeo, headlightMaterial);
        hlL.position.set(-size.width * 0.4, size.height * 0.4, size.depth / 2 + depthOffset);
        const hlR = hlL.clone();
        hlR.position.x = size.width * 0.4;
        carGroup.add(hlL, hlR);
        
        // Taillights (Back)
        const tlL = new THREE.Mesh(lightGeo, taillightMaterial);
        tlL.position.set(-size.width * 0.4, size.height * 0.4, -size.depth / 2 + depthOffset);
        const tlR = tlL.clone();
        tlR.position.x = size.width * 0.4;
        carGroup.add(tlL, tlR);
        
        // Detail 2: Blinkers
        const blinkerGeo = new THREE.BoxGeometry(size.width * 0.05, size.height * 0.05, 0.05);
        const blL = new THREE.Mesh(blinkerGeo, blinkerMaterial);
        blL.position.set(-size.width * 0.4, size.height * 0.4, size.depth / 2 + depthOffset - 0.06); 
        blL.visible = false;
        
        const blR = blL.clone();
        blR.position.x = size.width * 0.4;
        blR.name = 'blinkerRight';
        blL.name = 'blinkerLeft';
        carGroup.add(blL, blR);

        // Wheels (Detail 20: Will rotate in updateMotion)
        const wheelPositions = [
            { x: size.width * 0.45, z: size.depth * 0.3 },
            { x: -size.width * 0.45, z: size.depth * 0.3 },
            { x: size.width * 0.45, z: -size.depth * 0.3 },
            { x: -size.width * 0.45, z: -size.depth * 0.3 },
        ];

        wheelPositions.forEach(pos => {
            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel.position.set(pos.x, CAR_SIZE.width * 0.15, pos.z);
            wheel.userData.isWheel = true;
            carGroup.add(wheel);
        });

        return carGroup;
    }


    /** Creates a generic car mesh (used for player and standard traffic) with body, cabin, and wheels. */
    function createGenericCarMesh(color) {
        const carGroup = new THREE.Group();
        const material = new THREE.MeshStandardMaterial({ color: color, metalness: 0.5, roughness: 0.5 });
        
        // Main Body
        const mainBodyGeometry = new THREE.BoxGeometry(CAR_SIZE.width, CAR_SIZE.height, CAR_SIZE.depth);
        const mainBody = new THREE.Mesh(mainBodyGeometry, material);
        mainBody.position.y = CAR_SIZE.height / 2;
        carGroup.add(mainBody);

        // Cabin
        const cabinWidth = CAR_SIZE.width * 0.8;
        const cabinHeight = CAR_SIZE.height * 0.6;
        const cabinDepth = CAR_SIZE.depth * 0.6;
        const cabinGeometry = new THREE.BoxGeometry(cabinWidth, cabinHeight, cabinDepth);
        const cabinMaterial = new THREE.MeshStandardMaterial({ color: color - 0x111111, metalness: 0.3, roughness: 0.8 }); 
        
        const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
        cabin.position.y = CAR_SIZE.height + cabinHeight / 2;
        cabin.position.z = -CAR_SIZE.depth * 0.1;
        carGroup.add(cabin);

        carGroup.userData.carType = 'generic';
        carGroup.userData.collisionDepth = CAR_SIZE.depth;

        return addDetails(carGroup, CAR_SIZE);
    }

    /** Creates a truck mesh. */
    function createTruckMesh(color) {
        const carGroup = new THREE.Group();
        const material = new THREE.MeshStandardMaterial({ color: color, metalness: 0.3, roughness: 0.6 });

        // Main Body (Box)
        const mainBodyGeometry = new THREE.BoxGeometry(TRUCK_SIZE.width, TRUCK_SIZE.height, TRUCK_SIZE.depth);
        const mainBody = new THREE.Mesh(mainBodyGeometry, material);
        mainBody.position.y = TRUCK_SIZE.height / 2;
        carGroup.add(mainBody);

        // Cabin (Smaller box on the front)
        const cabinWidth = TRUCK_SIZE.width * 0.8;
        const cabinHeight = TRUCK_SIZE.height * 0.6;
        const cabinDepth = TRUCK_SIZE.depth * 0.25;
        const cabinGeometry = new THREE.BoxGeometry(cabinWidth, cabinHeight, cabinDepth);
        const cabinMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.3, roughness: 0.8 }); 
        
        const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
        cabin.position.y = TRUCK_SIZE.height + cabinHeight / 2;
        cabin.position.z = TRUCK_SIZE.depth * 0.3; // Position at the front
        carGroup.add(cabin);
        
        carGroup.userData.carType = 'truck';
        carGroup.userData.collisionDepth = TRUCK_SIZE.depth; 

        // Offset the depth for details since the body is pushed back
        return addDetails(carGroup, TRUCK_SIZE, 0); 
    }

    // Detail 5: Creates a van mesh.
    function createVanMesh(color) {
        const carGroup = new THREE.Group();
        const material = new THREE.MeshStandardMaterial({ color: color, metalness: 0.4, roughness: 0.7 });

        // Main Body (Tall Box)
        const mainBodyGeometry = new THREE.BoxGeometry(VAN_SIZE.width, VAN_SIZE.height, VAN_SIZE.depth);
        const mainBody = new THREE.Mesh(mainBodyGeometry, material);
        mainBody.position.y = VAN_SIZE.height / 2;
        carGroup.add(mainBody);

        carGroup.userData.carType = 'van';
        carGroup.userData.collisionDepth = VAN_SIZE.depth; 

        return addDetails(carGroup, VAN_SIZE); 
    }


    /** Creates a car mesh (randomly selects between types for traffic, or always generic for player). */
    function createCarMesh(color, isPlayer = false) {
        if (isPlayer) {
            const mesh = createGenericCarMesh(color);
            // Player car doesn't need AI properties
            mesh.userData.isCar = true;
            return mesh;
        }

        // Randomly choose car type for traffic (Details 5, 8, 9, 10)
        const carTypes = [createGenericCarMesh, createTruckMesh, createVanMesh];
        const weights = [70, 20, 10]; // 70% generic car, 20% truck, 10% van

        let totalWeight = 0;
        for (const weight of weights) { totalWeight += weight; }

        let random = Math.random() * totalWeight;
        let selectedType = createGenericCarMesh; 

        for (let i = 0; i < carTypes.length; i++) {
            random -= weights[i];
            if (random < 0) {
                selectedType = carTypes[i];
                break;
            }
        }

        const mesh = selectedType(color);
        
        mesh.userData.isCar = true;
        // Detail 1: Traffic AI properties
        mesh.userData.targetX = 0;
        mesh.userData.currentX = 0;
        mesh.userData.isSwitching = false;
        mesh.userData.laneChangeTimer = TRAFFIC_CHANGE_DECISION_INTERVAL * Math.random(); // Start randomly
        
        mesh.children.forEach(child => {
            child.castShadow = true;
            child.receiveShadow = true;
        });

        return mesh;
    }

    // Detail 15, 16: Overhead Street Light
    function createStreetLightMesh() {
        const group = new THREE.Group();
        
        // Pole (Thin cylinder)
        const poleGeo = new THREE.CylinderGeometry(0.05, 0.05, 5, 6);
        const poleMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8 });
        const pole = new THREE.Mesh(poleGeo, poleMat);
        pole.position.y = 2.5; 
        group.add(pole);

        // Light Arm (Horizontal bar)
        const armGeo = new THREE.BoxGeometry(1.5, 0.05, 0.05);
        const armMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        const arm = new THREE.Mesh(armGeo, armMat);
        arm.position.set(0.75, 5, 0); 
        group.add(arm);

        // Light Source (Glow)
        const lightGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.7 });
        const lightMesh = new THREE.Mesh(lightGeo, lightMat);
        lightMesh.position.set(1.5, 5, 0); 
        group.add(lightMesh);

        // Add a point light to simulate the glow
        const pointLight = new THREE.PointLight(0xffffff, 20, 10);
        pointLight.position.set(1.5, 5, 0);
        group.add(pointLight);

        group.userData.isBackgroundElement = true;
        group.userData.isStreetLight = true;
        return group;
    }


    /** Creates a background foliage mesh (tree, flower, or none). */
    function createBackgroundMesh(style, grassColor) {
        // ... (Existing foliage code remains here) ...
        const detailGroup = new THREE.Group();
        detailGroup.userData.isBackgroundElement = true;
        
        if (style === 'none' || style === 'lights') {
             // Detail 15, 16: Handle Street Lights for Night Ascent
            if (style === 'lights' && Math.random() < 0.3) { 
                return createStreetLightMesh();
            }
            return detailGroup; 
        }

        const trunkColor = 0x7c4912;
        let topColor = grassColor; 

        if (style === 'flowers') {
            const flowerColor = [0xFFC0CB, 0xFFA07A, 0x90EE90, 0xADD8E6][Math.floor(Math.random() * 4)];
            const geometry = new THREE.ConeGeometry(0.3, 0.4, 4);
            const material = new THREE.MeshBasicMaterial({ color: flowerColor });
            const flower = new THREE.Mesh(geometry, material);
            flower.position.y = 0.2;
            detailGroup.add(flower);
        } else {
            const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: trunkColor, roughness: 1 }); 
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.3; 
            detailGroup.add(trunk);

            let topGeometry, topYPos;
            if (style === 'snowy' || style === 'wet') {
                topGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
                topYPos = 1.3;
                topColor = style === 'snowy' ? 0xffffff : grassColor + 0x111111;
            } else {
                topGeometry = new THREE.ConeGeometry(0.4, 1.2, 8);
                topYPos = 1.2;
                if (style === 'autumn') {
                    topColor = [0x992d00, 0xcc6600, 0x4d3200][Math.floor(Math.random() * 3)];
                } else if (style === 'sparse') { // Detail 18: Coastal Sunset foliage
                     topColor = [0x008080, 0x6b8e23][Math.floor(Math.random() * 2)];
                }
            }

            const topMaterial = new THREE.MeshStandardMaterial({ color: topColor, metalness: 0, roughness: 0.7 }); 
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = topYPos; 
            detailGroup.add(top);
        }

        detailGroup.children.forEach(child => {
            child.castShadow = true;
            child.receiveShadow = true;
        });
        detailGroup.userData.isBackgroundElement = true;
        return detailGroup;
    }

    /** Creates and adds rain/snow particle systems. */
    function createWeatherParticleSystem(weatherType) {
        // ... (Existing weather code remains here) ...
        const particleCount = weatherType === 'rain' ? 2500 : 1800;
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const rainVolumeWidth = ROAD_WIDTH + 30;
        const zWrap = ROAD_DEPTH * 0.8;

        for (let i = 0; i < particleCount; i++) {
            positions.push( (Math.random() - 0.5) * rainVolumeWidth ); 
            positions.push( 15 + Math.random() * 10 ); 
            positions.push( FAR_Z_SPAWN + Math.random() * zWrap );
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

        let material;
        if (weatherType === 'rain') {
            material = new THREE.PointsMaterial({
                color: 0x99aaff,
                size: 0.15,
                transparent: true,
                opacity: 0.6,
            });
        } else if (weatherType === 'snow') {
            material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.35,
                transparent: true,
                opacity: 0.8,
            });
        }

        gameState.weatherParticles = new THREE.Points(geometry, material);
        gameState.weatherParticles.position.z = PLAYER_Z;
        gameState.weatherParticles.userData.isWeather = true;
        scene.add(gameState.weatherParticles);
    }

    /** Cleans up weather particle systems. */
    function cleanupWeather() {
        if (gameState.weatherParticles) {
            scene.remove(gameState.weatherParticles);
            gameState.weatherParticles.geometry?.dispose();
            gameState.weatherParticles.material?.dispose();
            gameState.weatherParticles = null;
        }
    }
    
    // --- SCENE INITIALIZATION ---

    /** Initializes the 3D scene, camera, and renderer. */
    function initThreeJS() {
        // ... (Existing initThreeJS code remains here) ...
        scene = new THREE.Scene();
        
        const initialEnv = ENVIRONMENTS[0];
        scene.fog = new THREE.Fog(initialEnv.skyColor, ROAD_DEPTH * initialEnv.fogNear, ROAD_DEPTH * initialEnv.fogFar);
        
        const initialWidth = window.innerWidth;
        const initialHeight = window.innerHeight;
        camera = new THREE.PerspectiveCamera(70, initialWidth / initialHeight, 0.1, ROAD_DEPTH + 50);
        camera.position.set(0, 2.5, PLAYER_Z + 3.5); 
        camera.lookAt(0, 0.5, 0); 

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(initialWidth, initialHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        CONTAINER.appendChild(renderer.domElement);

        window.addEventListener('resize', onWindowResize);
        clock = new THREE.Clock();

        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
        scene.add(hemisphereLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 30;
        scene.add(directionalLight);
    }
    
    /** Handles resizing the canvas and camera when the window size changes. */
    function onWindowResize() {
        // ... (Existing onWindowResize code remains here) ...
        if (!camera || !renderer) return;
        const newWidth = window.innerWidth;
        const newHeight = window.innerHeight;

        camera.aspect = newWidth / newHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(newWidth, newHeight);
    }
    
    /** Creates the static road and the animated lane markings. */
    function createRoad() {
        // ... (Existing createRoad code remains here) ...
        const roadGeometry = new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_DEPTH, 1, 150); 
        const roadMaterial = new THREE.MeshLambertMaterial({ color: CLASSIC_ROAD_COLOR });
        const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
        roadMesh.rotation.x = -Math.PI / 2; 
        roadMesh.position.y = 0; 
        roadMesh.position.z = -ROAD_DEPTH / 2 + PLAYER_Z; 
        roadMesh.receiveShadow = true;
        roadMesh.userData.isRoad = true;
        scene.add(roadMesh);
        
        const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const lineDepth = 1.2; 
        const lineGap = 1.8; 
        const totalPattern = lineDepth + lineGap;
        const numLines = Math.ceil(ROAD_DEPTH / totalPattern) * 2; 
        
        for (let i = 1; i < LANE_COUNT; i++) {
            const xPos = gameState.playerCar.lanePositions[i] - ROAD_WIDTH / LANE_COUNT / 2;
            
            const lineGroup = new THREE.Group();
            lineGroup.userData.isLaneLine = true;
            
            for (let j = 0; j < numLines; j++) {
                const lineGeometry = new THREE.PlaneGeometry(0.15, lineDepth);
                const lineMesh = new THREE.Mesh(lineGeometry, lineMaterial);
                
                lineMesh.rotation.x = -Math.PI / 2;
                lineMesh.position.set(xPos, 0.01, FAR_Z_SPAWN + j * totalPattern); 
                lineGroup.add(lineMesh);
            }
            lineGroup.userData.totalZExtent = numLines * totalPattern;
            scene.add(lineGroup);
        }

        const railingGeometry = new THREE.BoxGeometry(0.15, 0.4, ROAD_DEPTH); 
        const railingMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.3 }); 

        const leftRailing = new THREE.Mesh(railingGeometry, railingMaterial);
        leftRailing.position.set(-ROAD_WIDTH / 2 - 0.5, 0.2, -ROAD_DEPTH / 2 + PLAYER_Z);
        leftRailing.receiveShadow = true;
        leftRailing.castShadow = true;
        leftRailing.userData.isRoadDetail = true;
        scene.add(leftRailing);
        
        const rightRailing = new THREE.Mesh(railingGeometry, railingMaterial);
        rightRailing.position.set(ROAD_WIDTH / 2 + 0.5, 0.2, -ROAD_DEPTH / 2 + PLAYER_Z);
        rightRailing.receiveShadow = true;
        rightRailing.castShadow = true;
        rightRailing.userData.isRoadDetail = true;
        scene.add(rightRailing);
    }

    // --- GAME LOGIC FUNCTIONS ---

    /** Applies the speed and traffic multipliers based on the current level. */
    function scaleGameSpeed() {
        // ... (Existing scaleGameSpeed code remains here) ...
        const speedFactor = Math.pow(LEVEL_MULTIPLIER, gameState.level - 1); 

        MAX_PLAYER_SPEED = BASE_MAX_PLAYER_SPEED * speedFactor;
        IDLE_PLAYER_SPEED = BASE_IDLE_PLAYER_SPEED * speedFactor;
        TRAFFIC_SPEED = BASE_TRAFFIC_SPEED * speedFactor;
        ACCELERATION_RATE = BASE_ACCELERATION_RATE * speedFactor;
        DECELERATION_RATE = BASE_DECELERATION_RATE * speedFactor;
        
        gameState.playerSpeedUnits = Math.max(gameState.playerSpeedUnits, IDLE_PLAYER_SPEED);
    }

    /** Updates the scene's colors, fog, and light based on the current level/environment. */
    function updateEnvironment(newLevel) {
        // ... (Existing updateEnvironment code remains here) ...
        gameState.currentEnvironmentIndex = (newLevel - 1) % ENVIRONMENTS.length;
        const env = ENVIRONMENTS[gameState.currentEnvironmentIndex];

        cleanupWeather(); 
        
        scene.background = new THREE.Color(env.skyColor);
        scene.fog.color.set(env.skyColor);
        scene.fog.near = ROAD_DEPTH * env.fogNear;
        scene.fog.far = ROAD_DEPTH * env.fogFar;

        createBackgroundElements(env.foliageType, env.grassColor);
        
        if (env.weather === 'rain' || env.weather === 'snow') {
            createWeatherParticleSystem(env.weather);
        }

        environmentNameEl.textContent = env.name;
    }

    /** Creates static background elements (grass/shoulders and wrapping trees/flowers). */
    let grassMesh;
    function createBackgroundElements(foliageType, grassColor) {
        // ... (Existing createBackgroundElements code remains here) ...
        for (let i = scene.children.length - 1; i >= 0; i--) {
            const child = scene.children[i];
            if (child.userData.isBackgroundElement) { 
                scene.remove(child);
                child.geometry?.dispose();
                child.material?.dispose();
            }
        }
        gameState.backgroundElements = [];
        
        // 1. Grass/Ground Plane 
        const grassGeometry = new THREE.PlaneGeometry(ROAD_WIDTH + 30, ROAD_DEPTH); 
        const grassMaterial = new THREE.MeshLambertMaterial({ color: grassColor });
        grassMesh = new THREE.Mesh(grassGeometry, grassMaterial);
        grassMesh.rotation.x = -Math.PI / 2;
        grassMesh.position.y = -0.05; 
        grassMesh.position.z = -ROAD_DEPTH / 2 + PLAYER_Z;
        grassMesh.receiveShadow = true;
        grassMesh.userData.isBackgroundElement = true; 
        scene.add(grassMesh);

        // 2. Foliage (Animated/Wrapping)
        // Detail: Added more objects for denser background in non-lights environment
        const elementCount = foliageType === 'lights' ? DETAIL_COUNT / 2 : DETAIL_COUNT; 
        
        for (let i = 0; i < elementCount; i++) {
            const detailGroup = createBackgroundMesh(foliageType, grassColor); 
            
            let xPos = ROAD_WIDTH / 2 + 3 + Math.random() * 8;
            if (Math.random() > 0.5) {
                xPos = -xPos; 
            }

            const zPos = FAR_Z_SPAWN + Math.random() * (ROAD_DEPTH + 30); 

            detailGroup.position.set(xPos, 0, zPos);
            detailGroup.rotation.y = Math.random() * Math.PI * 2;
            
            scene.add(detailGroup);
            gameState.backgroundElements.push(detailGroup);
        }
    }

    /** Creates a traffic car and adds it to the scene. */
    function createTrafficCar(lane) { 
        const trafficColors = [0xe74c3c, 0xf1c40f, 0x9b59b6, 0x1abc9c, 0xecf0f1, 0x34495e, 0x95a5a6]; 
        const carColor = trafficColors[Math.floor(Math.random() * trafficColors.length)];

        const carMesh = createCarMesh(carColor, false);
        
        const carDepth = carMesh.userData.collisionDepth;
        
        const startX = gameState.playerCar.lanePositions[lane];

        carMesh.position.set(
            startX, 
            0, 
            FAR_Z_SPAWN + carDepth / 2 + Math.random() * 20 
        );

        carMesh.userData.lane = lane; 
        // Detail 1: Initialize targetX and currentX for AI
        carMesh.userData.targetX = startX;
        carMesh.userData.currentX = startX;
        
        scene.add(carMesh);
        gameState.traffic.push(carMesh);
    }
    
    /** * Checks if spawning a car in a given lane adheres to the minimum separation rules. */
    function isSpawnSafe(laneToSpawn) {
        // ... (Existing isSpawnSafe code remains here) ...
        const currentLane = laneToSpawn;
        const spawnZ = FAR_Z_SPAWN; 
        
        const relevantTraffic = gameState.traffic.filter(car => 
            car.position.z < PLAYER_Z + 10 
        );
        
        for (const car of relevantTraffic) {
            const carZ = car.position.z;
            const carDepth = car.userData.collisionDepth || CAR_SIZE.depth;
            
            // 1. Same-Lane Check (Longitudinal Separation)
            if (car.userData.lane === currentLane) {
                if (Math.abs(carZ - spawnZ) < carDepth * 0.5) {
                    return false; 
                }
                if (carZ - spawnZ < MIN_LONGITUDINAL_GAP && carZ - spawnZ > 0) {
                    return false; 
                }
            }
            
            // 2. Adjacent-Lane Check (Lateral Separation)
            const isAdjacent = Math.abs(car.userData.lane - currentLane) === 1;

            if (isAdjacent) {
                if (Math.abs(carZ - spawnZ) < MIN_LATERAL_GAP) {
                    return false;
                }
            }
        }
        
        const blockedLanes = new Set(); 
        
        for (const car of relevantTraffic) {
            if (Math.abs(car.position.z - spawnZ) < MIN_LONGITUDINAL_GAP * 0.75) { 
                blockedLanes.add(car.userData.lane);
            }
        }
        
        if (blockedLanes.size === LANE_COUNT) {
            return false;
        }

        return true; 
    }

    // Detail 11: Checks if a traffic car can safely switch to a new lane.
    function isLaneChangeSafe(car, newLane, deltaTime) {
        const currentLane = car.userData.lane;
        const targetX = gameState.playerCar.lanePositions[newLane];
        const carWidth = CAR_SIZE.width; // Use a conservative width
        
        // 1. Check if the target X position is clear of all traffic.
        // We only check for cars in the target lane and adjacent to the car's Z position.
        const trafficAhead = gameState.traffic.filter(otherCar => 
            otherCar !== car && 
            (otherCar.userData.lane === newLane || otherCar.userData.lane === currentLane)
        );

        const carDepth = car.userData.collisionDepth || CAR_SIZE.depth;
        const lookAheadDistance = carDepth * 3; // Check three car lengths ahead

        for (const otherCar of trafficAhead) {
            const otherCarZ = otherCar.position.z;
            const otherDepth = otherCar.userData.collisionDepth || CAR_SIZE.depth;

            // Longitudinal check: Is the other car too close?
            if (Math.abs(car.position.z - otherCarZ) < carDepth + otherDepth) {
                // Lateral check: If the other car is in the target lane
                if (otherCar.userData.lane === newLane) {
                    return false;
                }
            }

            // Check if there's space ahead in the current lane to prevent crashing before switching
            if (otherCar.userData.lane === currentLane && 
                otherCar.position.z > car.position.z &&
                otherCar.position.z - car.position.z < lookAheadDistance) 
            {
                // If the car ahead is much slower than the current car, it might be safer to switch
                const currentCarSpeed = gameState.playerSpeedUnits - TRAFFIC_SPEED; 
                if (currentCarSpeed > 5) {
                    return true; // We must switch, current lane is blocked
                }
            }
        }

        // 2. Check if the target position is clear of the player car (especially critical near the player)
        const player = gameState.playerCar.mesh;
        const playerZ = PLAYER_Z;
        const playerDepth = CAR_SIZE.depth;
        
        // Simplified check: If traffic car is near the player, assume danger
        if (Math.abs(car.position.z - playerZ) < carDepth * 2) {
            return false; 
        }

        return true; 
    }


    // Detail 1: Implements traffic AI (lane switching logic)
    function updateTrafficAI(carMesh, deltaTime) {
        const { userData } = carMesh;
        
        // 1. Update lateral position (smooth lane switch)
        userData.currentX += (userData.targetX - userData.currentX) * TRAFFIC_LANE_CHANGE_RATE * deltaTime * 10;
        carMesh.position.x = userData.currentX;

        // 2. Blinker Logic (Detail 3)
        gameState.lastBlinkerToggle += deltaTime;
        const blinkerLeft = carMesh.getObjectByName('blinkerLeft');
        const blinkerRight = carMesh.getObjectByName('blinkerRight');

        if (gameState.lastBlinkerToggle > BLINKER_INTERVAL) {
            if (userData.isSwitching) {
                // Flash the appropriate blinker
                if (userData.targetLane > userData.lane) {
                    if (blinkerRight) blinkerRight.visible = !blinkerRight.visible;
                } else if (userData.targetLane < userData.lane) {
                    if (blinkerLeft) blinkerLeft.visible = !blinkerLeft.visible;
                }
            } else {
                if (blinkerLeft) blinkerLeft.visible = false;
                if (blinkerRight) blinkerRight.visible = false;
            }
            gameState.lastBlinkerToggle = 0;
        }

        // 3. Lane Switching Decision
        if (userData.isSwitching && Math.abs(userData.targetX - userData.currentX) < 0.05) {
            // Lane switch completed
            userData.lane = userData.targetLane;
            userData.isSwitching = false;
            userData.laneChangeTimer = TRAFFIC_CHANGE_DECISION_INTERVAL + Math.random() * 2;
        }

        userData.laneChangeTimer -= deltaTime;

        if (!userData.isSwitching && userData.laneChangeTimer <= 0) {
            // Time to make a decision
            const currentLane = userData.lane;
            const availableLanes = [];
            
            // Try to switch to an adjacent lane, 50/50 left/right preference
            let preferredDirection = Math.random() < 0.5 ? -1 : 1;
            
            for (let i = 0; i < LANE_COUNT; i++) {
                const laneCandidate = (currentLane + i * preferredDirection + LANE_COUNT) % LANE_COUNT;
                if (laneCandidate !== currentLane) {
                    availableLanes.push(laneCandidate);
                }
            }

            for (const newLane of availableLanes) {
                if (isLaneChangeSafe(carMesh, newLane, deltaTime)) {
                    userData.targetLane = newLane;
                    userData.targetX = gameState.playerCar.lanePositions[newLane];
                    userData.isSwitching = true;
                    // Reset timer, but let the blinker flash for a bit before the switch is 'complete'
                    userData.laneChangeTimer = 0; 
                    return; 
                }
            }
            
            // If no switch, reset timer for next check
            userData.laneChangeTimer = 1.0; 
        }
    }


    /** Moves and wraps all dynamic elements to create the infinite road effect. */
    function updateMotion(deltaTime) {
        const playerCar = gameState.playerCar;
        const { playerSpeedUnits, traffic } = gameState;

        // 1. Update Player Car Speed
        if (gameState.isGassing) {
            gameState.playerSpeedUnits = Math.min(MAX_PLAYER_SPEED, playerSpeedUnits + ACCELERATION_RATE * deltaTime);
            gasPedalEl.classList.add('active', 'bg-green-500');
            brakePedalEl.classList.remove('active', 'bg-red-500');
            
        } else {
            if (playerSpeedUnits > IDLE_PLAYER_SPEED) {
                gameState.playerSpeedUnits = Math.max(IDLE_PLAYER_SPEED, playerSpeedUnits - DECELERATION_RATE * deltaTime);
            }
            gasPedalEl.classList.remove('active', 'bg-green-500');
            brakePedalEl.classList.add('active', 'bg-red-500');
        }

        // 2. Player Car Lane Change (Smooth movement)
        playerCar.currentX += (playerCar.targetX - playerCar.currentX) * playerCar.moveSpeed * deltaTime;
        playerCar.mesh.position.x = playerCar.currentX;

        // 3. Motion Calculations
        const trafficRelativeMoveDistance = (playerSpeedUnits - TRAFFIC_SPEED) * deltaTime;
        const roadMoveDistance = playerSpeedUnits * deltaTime;
        
        // 4. Move and Check Traffic Cars
        gameState.nearMissTimer = Math.max(0, gameState.nearMissTimer - deltaTime);

        for (let i = traffic.length - 1; i >= 0; i--) {
            const carMesh = traffic[i];
            
            // Detail 1: Update traffic car AI
            updateTrafficAI(carMesh, deltaTime);

            // Move car along Z-axis
            carMesh.position.z += trafficRelativeMoveDistance; 
            
            // Detail 20: Wheel rotation
            carMesh.children.filter(c => c.userData.isWheel).forEach(wheel => {
                // Rotation angle is proportional to the distance traveled
                const circumference = 2 * Math.PI * (CAR_SIZE.width * 0.15); 
                const rotations = trafficRelativeMoveDistance / circumference;
                wheel.rotation.x += rotations * Math.PI * 2; 
            });


            // Collision and Near-Miss Check
            const collisionResult = checkCollision(playerCar.mesh, carMesh, true);

            if (collisionResult === 'hit') {
                // Detail 14: Camera Shake on collision
                applyCameraShake(0.3);
                gameState.isGameOver = true;
                showGameOverScreen();
                return;
            } else if (collisionResult === 'near-miss' && gameState.nearMissTimer === 0) {
                // Detail 19: Activate near-miss bonus
                gameState.nearMissTimer = 1.5; // Bonus lasts for 1.5 seconds
                gameState.currentScoreMultiplier = NEAR_MISS_SCORE_MULTIPLIER;
            }

            if (carMesh.position.z > DESPAWN_Z) {
                scene.remove(carMesh);
                traffic.splice(i, 1);
            }
        }

        // 5. Move Lane Lines and Background Elements (Infinite Road Effect)
        scene.children.forEach(child => {
            if (child.userData.isLaneLine) {
                const totalZExtent = child.userData.totalZExtent;
                child.children.forEach(line => {
                    line.position.z += roadMoveDistance; 
                    if (line.position.z > PLAYER_Z + line.geometry.parameters.height) { 
                        line.position.z -= totalZExtent; 
                    }
                });
            } else if (child.userData.isBackgroundElement && child !== grassMesh) {
                child.position.z += roadMoveDistance; 
                if (child.position.z > DESPAWN_Z) {
                    child.position.z -= ROAD_DEPTH + 30; 
                }
            }
        });
        
        // 6. Player Car Wheel Rotation (Detail 20)
        playerCar.mesh.children.filter(c => c.userData.isWheel).forEach(wheel => {
            const circumference = 2 * Math.PI * (CAR_SIZE.width * 0.15);
            const rotations = roadMoveDistance / circumference;
            wheel.rotation.x += rotations * Math.PI * 2; 
        });

        // 7. Update Weather Particles
        updateWeatherParticles(deltaTime);
        
        // 8. Handle Score Multiplier visual (Detail 19)
        if (gameState.nearMissTimer > 0) {
             nearMissDisplayEl.style.opacity = 1;
             nearMissDisplayEl.textContent = `NEAR MISS! X${NEAR_MISS_SCORE_MULTIPLIER}`;
        } else {
            nearMissDisplayEl.style.opacity = 0;
            gameState.currentScoreMultiplier = 1.0;
        }
    }
    
    // Detail 14: Camera Shake effect
    function applyCameraShake(duration, intensity = 0.05) {
        if (camera.userData.isShaking) return;
        camera.userData.isShaking = true;
        let shakeTime = 0;
        
        const shakeLoop = () => {
            if (shakeTime >= duration) {
                camera.position.x = 0; 
                camera.position.y = 2.5;
                camera.userData.isShaking = false;
                return;
            }

            const xOffset = Math.random() * intensity * 2 - intensity;
            const yOffset = Math.random() * intensity * 2 - intensity;
            
            camera.position.x = xOffset;
            camera.position.y = 2.5 + yOffset;
            camera.lookAt(0, 0.5, 0);

            shakeTime += clock.getDelta();
            requestAnimationFrame(shakeLoop);
        };

        requestAnimationFrame(shakeLoop);
    }


    /** Animates and wraps the rain/snow particles. */
    function updateWeatherParticles(deltaTime) {
        // ... (Existing updateWeatherParticles code remains here) ...
        if (!gameState.weatherParticles) return;

        const env = ENVIRONMENTS[gameState.currentEnvironmentIndex];
        const positions = gameState.weatherParticles.geometry.attributes.position.array;
        const speedFactor = (gameState.playerSpeedUnits * 0.02); 
        
        let particleSpeed = 0; 
        let yOffset = 0;
        const zWrap = ROAD_DEPTH * 0.8;

        if (env.weather === 'rain') {
            particleSpeed = 100 * deltaTime + speedFactor; 
            yOffset = -50 * deltaTime;
        } else if (env.weather === 'snow') {
            particleSpeed = 20 * deltaTime + speedFactor; 
            yOffset = -5 * deltaTime;
        }

        for (let i = 0; i < positions.length; i += 3) {
            positions[i + 2] += particleSpeed;
            positions[i + 1] += yOffset; 
            
            positions[i] += Math.sin(positions[i + 2] * 0.1 + clock.getElapsedTime() * 0.5) * 0.05 * deltaTime * 60;

            if (positions[i + 2] > PLAYER_Z + 5) {
                positions[i + 2] -= zWrap;
                positions[i + 1] = 15 + Math.random() * 10;
            }
            
            if (positions[i + 1] < 0) {
                positions[i + 1] = 15 + Math.random() * 10;
            }
        }

        gameState.weatherParticles.geometry.attributes.position.needsUpdate = true;
    }

    /** Checks for collision between player car and traffic car (AABB simple check) */
    function checkCollision(player, trafficMesh, checkForNearMiss = false) {
        const playerZ = PLAYER_Z; 
        const trafficZ = trafficMesh.position.z;
        const halfWidth = CAR_SIZE.width / 2;
        const halfPlayerDepth = CAR_SIZE.depth / 2;
        
        const trafficCollisionDepth = trafficMesh.userData.collisionDepth || CAR_SIZE.depth; 
        const trafficHalfDepth = trafficCollisionDepth / 2; 

        // 1. X-axis overlap check
        const playerMinX = player.position.x - halfWidth * 0.9; 
        const playerMaxX = player.position.x + halfWidth * 0.9;
        const trafficMinX = trafficMesh.position.x - halfWidth * 0.9;
        const trafficMaxX = trafficMesh.position.x + halfWidth * 0.9;

        const xOverlap = Math.max(0, Math.min(playerMaxX, trafficMaxX) - Math.max(playerMinX, trafficMinX));
        const zOverlapAllowance = 0.1; // Tolerance for collision

        if (xOverlap > CAR_SIZE.width * 0.1) {
            // 2. Z-axis overlap
            const playerFrontZ = playerZ + halfPlayerDepth;
            const playerBackZ = playerZ - halfPlayerDepth;
            const trafficFrontZ = trafficZ + trafficHalfDepth;
            const trafficBackZ = trafficZ - trafficHalfDepth;

            if (playerFrontZ > trafficBackZ + zOverlapAllowance && playerBackZ < trafficFrontZ - zOverlapAllowance) {
                return 'hit';
            }
            
            // Detail 19: Near-miss check (Player passed close to a car)
            if (checkForNearMiss) {
                const longitudinalGap = Math.abs(playerZ - trafficZ) - (halfPlayerDepth + trafficHalfDepth);
                if (longitudinalGap > 0 && longitudinalGap < NEAR_MISS_DISTANCE && xOverlap > CAR_SIZE.width * 0.5) {
                    return 'near-miss';
                }
            }
        }
        return 'none';
    }


    /** Updates UI elements and checks for level progression. */
    function updateUI(deltaTime) {
        const { score, level, playerSpeedUnits, currentScoreMultiplier } = gameState;
        
        // Score update (Detail 19: Apply score multiplier)
        gameState.score += playerSpeedUnits * deltaTime * 10 * currentScoreMultiplier; 
        scoreEl.textContent = Math.floor(gameState.score);
        
        // Speed update
        speedValueEl.textContent = Math.floor(playerSpeedUnits * SPEED_UNIT_TO_MPH);

        // Level check
        const newLevel = Math.floor(score / 3500) + 1; 
        if (newLevel > level) {
            gameState.level = newLevel;
            levelEl.textContent = gameState.level;
            scaleGameSpeed(); 
            updateEnvironment(gameState.level); 
        }
    }


    // --- GAME CONTROL FUNCTIONS ---
    
    /** Global function to update keybindings from the settings menu. */
    window.updateKeybinding = function(action, elementId) {
        const button = document.getElementById(elementId);
        const originalText = button.textContent;
        button.textContent = 'Press a key...';
        
        const handler = (e) => {
            const newKey = e.key;
            
            for (const key in gameState.keyBindings) {
                if (key !== action && gameState.keyBindings[key] === newKey) {
                    alert(`Key '${newKey}' is already used for ${key.toUpperCase()}.`);
                    button.textContent = originalText; 
                    document.removeEventListener('keydown', handler);
                    return;
                }
            }

            gameState.keyBindings[action] = newKey;
            button.textContent = newKey;

            updateControlsInfo(); 
            
            document.removeEventListener('keydown', handler);
        };

        button.blur(); 
        
        document.removeEventListener('keydown', handler);
        document.addEventListener('keydown', handler, { once: true });
    };

    /** Updates the on-screen controls info with the current keybindings. */
    function updateControlsInfo() {
        // ... (Existing updateControlsInfo code remains here) ...
        const gasKey = gameState.keyBindings.gas;
        const leftKey = gameState.keyBindings.left;
        const rightKey = gameState.keyBindings.right;
        
        const gasDisplay = gasKey === ' ' ? 'Spacebar' : gasKey;
        const leftDisplay = leftKey === ' ' ? 'Spacebar' : leftKey;
        const rightDisplay = rightKey === ' ' ? 'Spacebar' : rightKey;

        controlsInfoEl.innerHTML = `<p class="font-semibold">Controls: **Gas:** ${gasDisplay} (or Hold) | **Steer:** ${leftDisplay}/${rightDisplay}</p>`;
    }


    /** Shows the main menu screen. */
    function showMainMenu() {
        // ... (Existing showMainMenu code remains here) ...
        infoPanelEl.classList.add('hidden');
        controlsInfoEl.classList.add('hidden');
        pedalsContainerEl.classList.add('hidden');
        nearMissDisplayEl.style.opacity = 0;
        
        for (let i = scene.children.length - 1; i >= 0; i--) {
            const child = scene.children[i];
            if (child.userData.isCar || child.userData.isLaneLine || child.userData.isRoad || child.userData.isBackgroundElement || child.userData.isWeather || child.userData.isRoadDetail) {
                scene.remove(child);
                child.geometry?.dispose();
                child.material?.dispose();
            }
        }

        modalContainerEl.innerHTML = `
            <div class="modal-overlay">
                <div class="menu-card rounded-2xl p-8 md:p-12 text-center text-white w-11/12 md:w-96">
                    <h1 class="text-6xl font-extrabold mb-4 text-yellow-400 tracking-wider shadow-white">RADIAL RACE</h1>
                    <p class="text-xl text-gray-300 mb-2">Endless high-speed highway action.</p>
                    <p class="text-lg text-yellow-300 font-bold mb-8">HIGH SCORE: ${gameState.highScore}</p>
                    
                    <div class="space-y-4">
                        <button onclick="startGame()" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-4 rounded-lg shadow-lg transition duration-200 text-xl tracking-wider">
                            START RACE
                        </button>
                        <button onclick="showHowToPlay()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg shadow-md transition duration-200">
                            HOW TO PLAY
                        </button>
                        <button onclick="showSettingsMenu()" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 rounded-lg shadow-md transition duration-200">
                            SETTINGS (Keybinds)
                        </button>
                        </div>
                </div>
            </div>
        `;
    }

    /** Shows the instructions modal. */
    window.showHowToPlay = function() {
        // ... (Existing showHowToPlay code remains here) ...
        modalContainerEl.innerHTML = `
            <div class="modal-overlay">
                <div class="menu-card rounded-2xl p-8 md:p-12 text-white w-11/12 md:w-1/3">
                    <h2 class="text-4xl font-extrabold mb-4 text-blue-400 text-center">HOW TO PLAY</h2>
                    
                    <div class="flex-shrink-0"> 
                        <ul class="list-none space-y-4 text-lg text-left">
                            <li class="p-3 bg-gray-700 rounded-lg">
                                <span class="font-bold text-green-300">ACCELERATE:</span> Hold the <span class="font-mono bg-gray-800 px-2 py-1 rounded">GAS Key (${gameState.keyBindings.gas})</span> to increase speed. Release to slow down.
                            </li>
                            <li class="p-3 bg-gray-700 rounded-lg">
                                <span class="font-bold text-yellow-300">STEERING:</span> Use <span class="font-mono bg-gray-800 px-2 py-1 rounded">LEFT Key (${gameState.keyBindings.left})</span> / <span class="font-mono bg-gray-800 px-2 py-1 rounded">RIGHT Key (${gameState.keyBindings.right})</span> to switch lanes.
                            </li>
                            <li class="p-3 bg-gray-700 rounded-lg">
                                <span class="font-bold text-red-300">OBJECTIVE:</span> Avoid traffic. Your score is based on distance traveled at speed. **Near Misses give a temporary X${NEAR_MISS_SCORE_MULTIPLIER} score multiplier!**
                            </li>
                            <li class="p-3 bg-gray-700 rounded-lg">
                                <span class="font-bold text-indigo-300">PAUSE:</span> Press the <span class="font-mono bg-gray-800 px-2 py-1 rounded">SPACEBAR</span> at any time.
                            </li>
                        </ul>
                    </div>

                    <button onclick="showMainMenu()" class="mt-8 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 rounded-lg transition duration-200">BACK TO MENU</button>
                </div>
            </div>
        `;
    }

    /** Shows the settings menu modal for keybinding customization. */
    window.showSettingsMenu = function() {
        // ... (Existing showSettingsMenu code remains here) ...
        modalContainerEl.innerHTML = `
            <div class="modal-overlay">
                <div class="menu-card rounded-2xl p-8 md:p-12 text-white w-11/12 md:w-1/3">
                    <h2 class="text-4xl font-extrabold mb-6 text-purple-400 text-center">GAME SETTINGS</h2>
                    
                    <h3 class="text-2xl font-bold mb-4 text-gray-200">Key Bindings</h3>

                    <div class="space-y-4">
                        <div class="flex justify-between items-center p-3 bg-gray-700 rounded-lg">
                            <span class="font-bold text-green-300">Gas/Accelerate:</span>
                            <button id="keybind-gas" onclick="updateKeybinding('gas', 'keybind-gas')" class="bg-gray-900 hover:bg-gray-800 text-yellow-300 font-mono py-2 px-4 rounded transition duration-150 text-base">
                                ${gameState.keyBindings.gas}
                            </button>
                        </div>
                        <div class="flex justify-between items-center p-3 bg-gray-700 rounded-lg">
                            <span class="font-bold text-yellow-300">Steer Left:</span>
                            <button id="keybind-left" onclick="updateKeybinding('left', 'keybind-left')" class="bg-gray-900 hover:bg-gray-800 text-yellow-300 font-mono py-2 px-4 rounded transition duration-150 text-base">
                                ${gameState.keyBindings.left}
                            </button>
                        </div>
                        <div class="flex justify-between items-center p-3 bg-gray-700 rounded-lg">
                            <span class="font-bold text-yellow-300">Steer Right:</span>
                            <button id="keybind-right" onclick="updateKeybinding('right', 'keybind-right')" class="bg-gray-900 hover:bg-gray-800 text-yellow-300 font-mono py-2 px-4 rounded transition duration-150 text-base">
                                ${gameState.keyBindings.right}
                            </button>
                        </div>
                    </div>

                    <p class="text-sm text-gray-400 mt-4 text-center">Click a button above, then press the key you want to use.</p>

                    <button onclick="showMainMenu()" class="mt-8 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 rounded-lg transition duration-200">BACK TO MENU</button>
                </div>
            </div>
        `;
    }


    /** Toggles the game's paused state and shows the modal. */
    window.togglePause = function() {
        // ... (Existing togglePause code remains here) ...
        if (gameState.isGameOver) return; 

        gameState.isPaused = !gameState.isPaused;

        if (gameState.isPaused) {
            pauseButtonEl.textContent = 'RESUME (Space)';
            modalContainerEl.innerHTML = `
                <div class="modal-overlay">
                    <div class="menu-card rounded-xl p-10 text-center text-white shadow-2xl z-50 w-11/12 md:w-1/3">
                        <h2 class="text-4xl font-extrabold mb-4 text-yellow-400">GAME PAUSED</h2>
                        <p class="text-lg mb-6">Take a breath. Press 'RESUME' or the Spacebar to get back on the road.</p>
                        <button onclick="togglePause()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition duration-200">RESUME</button>
                    </div>
                </div>
            `;
            cancelAnimationFrame(animationFrameId);
        } else {
            pauseButtonEl.textContent = 'PAUSE (Space)';
            modalContainerEl.innerHTML = '';
            gameLoop();
        }
    }

    /** Displays the Game Over modal */
    function showGameOverScreen() {
        // Detail 12, 13: Update and display High Score
        if (gameState.score > gameState.highScore) {
            gameState.highScore = Math.floor(gameState.score);
            localStorage.setItem('radialRacerHighScore', gameState.highScore);
            highScoreDisplayEl.textContent = gameState.highScore;
        }

        modalContainerEl.innerHTML = `
            <div class="modal-overlay">
                <div class="menu-card bg-red-900 border-2 border-red-500 rounded-xl p-10 text-center text-white shadow-2xl z-50 w-11/12 md:w-1/3">
                    <h2 class="text-5xl font-extrabold mb-4 text-red-300">CRASH! GAME OVER!</h2>
                    <p class="text-2xl mb-2">Final Score: <span class="text-yellow-400 font-extrabold">${Math.floor(gameState.score)}</span></p>
                    <p class="text-xl mb-6 text-yellow-300 font-bold">HIGH SCORE: ${gameState.highScore}</p>
                    <button onclick="showMainMenu()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-200">BACK TO MENU</button>
                </div>
            </div>
        `;
        pauseButtonEl.textContent = 'CRASHED';
        cancelAnimationFrame(animationFrameId);
        infoPanelEl.classList.add('hidden');
        controlsInfoEl.classList.add('hidden');
        pedalsContainerEl.classList.add('hidden');
    }
    
    /** Resets the game state and initializes all objects for a new game. */
    window.startGame = function() {
        // ... (Existing startGame code remains here) ...
        for (let i = scene.children.length - 1; i >= 0; i--) {
            const child = scene.children[i];
            if (child.userData.isCar || child.userData.isLaneLine || child.userData.isRoad || child.userData.isBackgroundElement || child.userData.isWeather || child.userData.isRoadDetail) {
                scene.remove(child);
                child.geometry?.dispose();
                child.material?.dispose();
            }
        }
        
        gameState.score = 0;
        gameState.level = 1;
        gameState.isGameOver = false;
        gameState.isPaused = false;
        gameState.traffic = [];
        gameState.backgroundElements = [];
        gameState.lastTrafficSpawn = 0;
        // Detail 19: Reset score multiplier
        gameState.nearMissTimer = 0;
        gameState.currentScoreMultiplier = 1.0;
        nearMissDisplayEl.style.opacity = 0;
        cleanupWeather(); 

        scaleGameSpeed(); 
        gameState.playerSpeedUnits = IDLE_PLAYER_SPEED;
        
        if (gameState.playerCar.lanePositions.length === 0) {
            calculateLanePositions();
        }

        gameState.playerCar.mesh = createCarMesh(0x3498db, true); 
        gameState.playerCar.lane = 1;
        gameState.playerCar.mesh.position.set(gameState.playerCar.lanePositions[gameState.playerCar.lane], 0, PLAYER_Z);
        gameState.playerCar.targetX = gameState.playerCar.lanePositions[gameState.playerCar.lane];
        gameState.playerCar.currentX = gameState.playerCar.lanePositions[gameState.playerCar.lane];
        scene.add(gameState.playerCar.mesh);

        createRoad();
        updateEnvironment(1); 
        
        infoPanelEl.classList.remove('hidden');
        controlsInfoEl.classList.remove('hidden');
        pedalsContainerEl.classList.remove('hidden');
        scoreEl.textContent = 0;
        levelEl.textContent = 1;
        modalContainerEl.innerHTML = '';
        pauseButtonEl.textContent = 'PAUSE (Space)';
        
        updateControlsInfo(); 

        gasPedalEl.classList.remove('active', 'bg-green-500');
        brakePedalEl.classList.add('active', 'bg-red-500'); 
        
        clock.start();
        gameLoop();
    }


    // --- MAIN GAME LOOP ---

    function gameLoop() {
        // ... (Existing gameLoop code remains here) ...
        if (gameState.isGameOver || gameState.isPaused) {
            cancelAnimationFrame(animationFrameId);
            return;
        }
        
        const deltaTime = clock.getDelta(); 
        
        updateMotion(deltaTime);
        
        updateUI(deltaTime);

        renderer.render(scene, camera);

        animationFrameId = requestAnimationFrame(gameLoop);
    }


    // --- INPUT HANDLING ---

    document.addEventListener('keydown', (e) => {
        // ... (Existing keydown code remains here) ...
        if (gameState.isGameOver) return;
        
        if (e.key === ' ' || e.key === 'Spacebar') {
            e.preventDefault();
            togglePause();
            return;
        }

        if (gameState.isPaused) return;

        let newLane = gameState.playerCar.lane;

        if (e.key === gameState.keyBindings.left) {
            newLane = Math.max(0, gameState.playerCar.lane - 1);
        } else if (e.key === gameState.keyBindings.right) {
            newLane = Math.min(LANE_COUNT - 1, gameState.playerCar.lane + 1);
        } else if (e.key === gameState.keyBindings.gas) {
            gameState.isGassing = true;
        } else if (e.key === 'ArrowDown') { 
            gameState.isGassing = false; 
        }
        
        if (newLane !== gameState.playerCar.lane) {
            gameState.playerCar.lane = newLane;
            gameState.playerCar.targetX = gameState.playerCar.lanePositions[newLane];
        }
    });
    
    document.addEventListener('keyup', (e) => {
        // ... (Existing keyup code remains here) ...
        if (e.key === gameState.keyBindings.gas) {
            gameState.isGassing = false;
        }
    });

    // --- INITIALIZATION ---

    window.onload = function () {
        initThreeJS();
        showMainMenu(); 
    }
</script>

</body>
</html>
